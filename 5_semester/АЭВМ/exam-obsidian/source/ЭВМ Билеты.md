
- [[#1. Понятие о структурной организации и архитектуре компьютерных систем|1. Понятие о структурной организации и архитектуре компьютерных систем]]
- [[#2. Принципы концепции машины с хранимой в памяти программой|2. Принципы концепции машины с хранимой в памяти программой]]
- [[#3. Структура ЭВМ согласно принципам фон Неймана|3. Структура ЭВМ согласно принципам фон Неймана]]
- [[#4. Архитектура системы команд (АСК). Классификация АСК по составу и сложности команд|4. Архитектура системы команд (АСК). Классификация АСК по составу и сложности команд]]
- [[#5. АСК. Стековая архитектура|5. АСК. Стековая архитектура]]
- [[#6. АСК. Регистровая архитектура|6. АСК. Регистровая архитектура]]
- [[#7. АСК. Аккумуляторная архитектура|7. АСК. Аккумуляторная архитектура]]
- [[#8. АСК. Архитектура с выделенным доступом к памяти|8. АСК. Архитектура с выделенным доступом к памяти]]
- [[#9. АСК. CISC-архитектура|9. АСК. CISC-архитектура]]
- [[#10. АСК. RISC-архитектура|10. АСК. RISC-архитектура]]
- [[#11. АСК. VLIW-архитектура|11. АСК. VLIW-архитектура]]
- [[#12. Типы и форматы данных. Числа с фиксированной запятой|12. Типы и форматы данных. Числа с фиксированной запятой]]
- [[#13. Типы и форматы данных. Числа с плавающей запятой|13. Типы и форматы данных. Числа с плавающей запятой]]
- [[#14. Типы и форматы данных. BCD-числа|14. Типы и форматы данных. BCD-числа]]
- [[#15. Типы и форматы данных. Символьная информация, логические данные, строки|15. Типы и форматы данных. Символьная информация, логические данные, строки]]
- [[#16. Типы и форматы данных. Видео- и аудиоинформация|16. Типы и форматы данных. Видео- и аудиоинформация]]
- [[#17. Сложные структуры данных. Особенности их обработки|17. Сложные структуры данных. Особенности их обработки]]
- [[#18. Функциональная классификация команд|18. Функциональная классификация команд]]
- [[#19. Машинные команды. Арифметико-логические команды и команды сдвига|19. Машинные команды. Арифметико-логические команды и команды сдвига]]
- [[#20. Машинные команды. Команды пересылки и команды ввода-вывода|20. Машинные команды. Команды пересылки и команды ввода-вывода]]
- [[#21. Машинные команды. SIMD-команды. Команды работы со строками|21. Машинные команды. SIMD-команды. Команды работы со строками]]
- [[#22. Машинные команды. Команды передачи управления|22. Машинные команды. Команды передачи управления]]
- [[#23. Представление команд в ЭВМ. Форматы команд|23. Представление команд в ЭВМ. Форматы команд]]
- [[#24. Способы адресации. Непосредственная, прямая и косвенная адресации|24. Способы адресации. Непосредственная, прямая и косвенная адресации]]
- [[#25. Способы адресации. Базовая, индексная и относительная адресации|25. Способы адресации. Базовая, индексная и относительная адресации]]
- [[#26. Способы адресации. Адресации с автоувеличением, автоуменьшением, страничная адресация|26. Способы адресации. Адресации с автоувеличением, автоуменьшением, страничная адресация]]
- [[#27. Цикл выполнения команды в процессоре|27. Цикл выполнения команды в процессоре]]
- [[#28. Процессор. Одношинная архитектура|28. Процессор. Одношинная архитектура]]
- [[#29. Многошинная архитектура процессора|29. Многошинная архитектура процессора]]
- [[#30. Принцип микропрограммного управления|30. Принцип микропрограммного управления]]
- [[#31. Структура устройства управления. Микропрограммный автомат (МПА)|31. Структура устройства управления. Микропрограммный автомат (МПА)]]
- [[#32. МПА с жесткой логикой|32. МПА с жесткой логикой]]
- [[#33. МПА с программируемой логикой|33. МПА с программируемой логикой]]
- [[#34. Запоминающие устройства (ЗУ). Характеристики ЗУ|34. Запоминающие устройства (ЗУ). Характеристики ЗУ]]
- [[#35. Запоминающие устройства (ЗУ). Классификация ЗУ|35. Запоминающие устройства (ЗУ). Классификация ЗУ]]
- [[#36. Запоминающие устройства (ЗУ). Основная память|36. Запоминающие устройства (ЗУ). Основная память]]
- [[#37. Запоминающие устройства (ЗУ). Стековая память|37. Запоминающие устройства (ЗУ). Стековая память]]
- [[#38. Запоминающие устройства (ЗУ). Ассоциативная память|38. Запоминающие устройства (ЗУ). Ассоциативная память]]
- [[#39. Кэш-память. Структурная организация|39. Кэш-память. Структурная организация]]
- [[#40. Способы отображения оперативной памяти на кэш-память|40. Способы отображения оперативной памяти на кэш-память]]
- [[#41. Виртуальная память. Варианты ее организации|41. Виртуальная память. Варианты ее организации]]
- [[#42. Конвейерная обработка. Основы конвейеризации|42. Конвейерная обработка. Основы конвейеризации]]
- [[#43. Конфликты в конвейере команд. Риск по данным|43. Конфликты в конвейере команд. Риск по данным]]
- [[#44. Конфликты в конвейере команд. Риск по управлению|44. Конфликты в конвейере команд. Риск по управлению]]
- [[#45. Структурные конфликты в конвейере команд|45. Структурные конфликты в конвейере команд]]
<div style="page-break-after: always;"></div>

# 1. Понятие о структурной организации и архитектуре компьютерных систем

- **Вычислительная машина** - *комплекс технических и программных средств*, предназначенный для автоматизации подготовки и решения задач пользователей.
- **ЭВМ** – *ВМ*, основные функциональные устройства которой выполнены на электронных компонентах.
- **Вычислительная система** - *совокупность* взаимосвязанных и взаимодействующих процессоров или вычислительных машин, периферийного оборудования и программного обеспечения, предназначенная для подготовки и решения задач пользователей.
- **Архитектура ВМ** – логическая *структура* и функциональные *характеристики* ВМ, включая взаимосвязи между ее аппаратными и программными компонентами.

**Под структурной организацией ЭВМ** (электронной вычислительной машины) понимается некоторая физическая модель, *устанавливающая состав, порядок и принципы взаимодействия основных функциональных частей машины* (без излишних деталей их технической реализации).

![[Pasted image 20231220161918.png|500]]

<div style="page-break-after: always;"></div>

# 2. Принципы концепции машины с хранимой в памяти программой

**Основные принципы:**

1. **Принцип двоичного кодирования** - вся информация, как данные так и команды, *кодируются двоичными цифрами 0 и 1*. Каждый тип информации представляется двоичной последовательностью и имеет свой формат.
2. **Принцип программного управления** - все *вычисления должны быть представлены в виде программы*, состоящей из последовательности управляющих слоев - *команд*, которые хранятся в последовательных ячейкам памяти ВМ и выполняются в естественной последовательности.
3. **Принцип однородности памяти** - команды и *данные* хранятся в одной и той же памяти и внешне в памяти *неразличимы*.  Распознать их можно только по способу использования; то есть одно и то же значение в ячейке памяти может использоваться и как данные, и как команда, и как адрес в зависимости лишь от способа обращения к нему.
4. **Принцип адресности** - основная *память состоит из пронумерованных ячеек*, причем процессору в произвольный момент доступна любая ячейка, для этого используется ее номер или адрес.

Принцип машины с хранимой в памяти программой обеспечивает эффективное и универсальное исполнение различных задач и является основой для большинства современных компьютерных систем. Этот принцип позволяет создавать гибкие и мощные вычислительные устройства, способные адаптироваться к различным потребностям пользователей.
<div style="page-break-after: always;"></div>

# 3. Структура ЭВМ согласно принципам фон Неймана

> [!tldr] TL:DR
> - Принципы фон Неймана – базовая архитектурная концепция ЭВМ.
> - Структура машины: *ЗУ*, *АЛУ*, *УУ*, устройство ввода/вывода.
> - Программы и *данные вводятся в память* через *АЛУ*.
> - Команда включает операцию, адреса данных и место для результата.
> - *АЛУ* выполняет операции над данными.
> - Результаты *АЛУ* сохраняются в *ЗУ* или устройство вывода.
> - Различие между *ЗУ* и устройством вывода: в *ЗУ* данные обрабатываются, на устройства вывода поступают в удобной для человека форме.

Принципы фон Неймана представляют собой базовую архитектурную концепцию для построения электронных вычислительных машин (ЭВМ).

**Машина фон Неймана состоит из:**
- запоминающего устройства (*ЗУ*) (иначе памяти) 
- арифметико-логического устройства (*АЛУ*)
- устройства управления (*УУ*)
- устройства ввода и вывода.

![[Pasted image 20231220163142.png]]

Программы и *__данные вводятся в память__ из устройства ввода через арифметико-логическое устройство*. Все команды программы записываются в соседние ячейки памяти, а данные для обработки могут содержаться в произвольных ячейках. У любой программы последняя команда должна быть командой завершения работы.

>[!info] Зачем УУ?
> При выполнении программы **УУ на входе получает очередную инструкцию** или команду программы, которая поступает в регистр команд. Код операции поступает в дешифратор операции, который запускает последовательность смены состояний конечного автомата УУ, в современных машинах - запускает некоторую микропрограмму хранящуюся в ПЗУ микропрограмм.
>  
> ![[Pasted image 20231224161900.png]]
> 
> Суть работы УУ заключается в последовательном выставлении комбинаций сигналов управления на линиях управления. Тоесть на выход УУ выдает **последовательности импульсов управления** ( арифметико-логическим устройством, подсистемой ввода/вывода, оперативной памятью и другие).

**Команда** состоит из указания, какую операцию следует выполнить (из возможных операций на данном железе) и адресов ячеек памяти, где хранятся данные, над которыми следует выполнить указанную операцию, а также адреса ячейки, куда следует записать результат (если его требуется сохранить в *ЗУ*).

**АЛУ** **выполняет** указанные командами **операции** над указанными данными.

Из *АЛУ* результаты выводятся в память или устройство вывода. Принципиальное различие между *ЗУ* и устройством вывода заключается в том, что в *ЗУ данные хранятся в виде, удобном для обработки* компьютером, а на *устройства вывода* (принтер, монитор и др.) поступают так, *как удобно человеку*.
<div style="page-break-after: always;"></div>

# 4. Архитектура системы команд (АСК). Классификация АСК по составу и сложности команд

> [!tldr] TL:DR
> - **Система команд ВМ**: перечень команд ВМ.
> - **Архитектура системы команд (АСК)**: средства взаимодействия программиста с аппаратурой.
> - **Конечная цель ВМ**: эффективные вычисления за минимальное время.
> - **Влияние выбора архитектуры**: адреса команд, их длина, доступ к операндам, общая длина команд.
> - **Классификация по составу**: *CISC* (Complex Instruction Set Computer), *RISC* (Reduced Instruction Set Computer), *VLIW* (Very Long Instruction Word).
> - **Классификация по месту хранения операндов**: стековая, аккумуляторная, регистровая, с выделенным доступом к памяти.

**Система команд ВМ** - полный перечень команд, которые способна выполнять данная ВМ.

**Архитектура системы команд (АСК)** - те средства вычислительной машины, которые видны и *доступны программисту*. АСК можно рассматривать как *линию согласования нужд* разработчиков программного обеспечения с возможностями создателей аппаратуры вычислительной машины.

**Конечная цель** создания ВМ - реализация вычислений наиболее эффективным образом и за минимальное время.

Общая характеристика архитектуры системы команд вычислительной машины складывается из ответов на следующие вопросы:
1. Какого вида данные будут представлены в вычислительной машине и в какой форме?
2. Где эти данные могут храниться помимо основной памяти?
3. Каким образом будет осуществляться доступ к данным?
4. Какие операции могут быть выполнены над данными?
5. Сколько операндов может присутствовать в команде?
6. Как будет определяться адрес очередной команды?
7. Каким образом будут закодированы команды?

![[Pasted image 20231214193817.png]]


Выбор той или иной **архитектуры влияет** на принципиальные моменты:
- сколько адресов будет содержать адресная часть команд;
- какова будет длина этих адресов;
- насколько просто будет происходить доступ к операндам;
- какой будет общая длина команд.

## Классификация

### По составу
Современная технология программирования ориентирована на языки высокого уровня (ЯВУ). Но переход к ЯВУ породил серьезную проблему: семантический разрыв (сложные операторы ЯВУ существенно отличаются от простых машинных операций в ВМ).

- архитектура с полным набором команд: [[#9. АСК. CISC-архитектура|CISC]] (Complex Instruction Set Computer)
- архитектура с сокращенным набором команд: [[#10. АСК. RISC-архитектура|RISK]] (Reduced Instruction Set Computer)
- архитектура с командными словами сверхбольшой длины: [[#11. АСК. VLIW-архитектура|VLIW]] (Very Long Instruction Word)

![[Pasted image 20231214194440.png]]

### По месту хранения операндов
- стековую
- аккумуляторную
- регистровую
- с выделенным доступом к памяти
<div style="page-break-after: always;"></div>
# 5. АСК. Стековая архитектура

> [!tldr] TL:DR
> - **Стек** - логически связанные ячейки памяти, действующие по принципу *LIFO*.
> - **Структура стека**: вершина, операции **push** и **pop**, запись только в вершину, чтение только из вершины.
> - Информация заносится из памяти или *АЛУ* в вершину стека.
> - **Арифметические операции**: данные из двух верхних ячеек стека передаются *АЛУ*, результат автоматически возвращается в вершину.
> - **Достоинства АСК на базе стека**: сокращение адресной части команд, компактный код, простое декодирование.
> - **Недостатки АСК на базе стека**: отсутствие произвольного доступа к памяти, ограничение производительности.
> - **Примеры стековых архитектур**: `JVM`, `Forth-процессоры`.

**Стек** - память, по своей структурной организации отличная от основной памяти ВМ. Стек образует множество логически взаимосвязанных ячеек, взаимодействующих по принципу *LIFO (Last In First Out)*.
## Структура стека
- Верхнюю ячейку называют **вершиной стека**.
- Для работы со стеком предусмотрены две операции: **push** и **pop** .
- Запись возможна **только в верхнюю ячейку** стека, при этом вся хранящаяся в стеке информация предварительно *проталкивается на одну позицию вниз*.
- Чтение допустимо *также только из вершины* стека.
- **Операнды** перед обработкой **помещаются в две верхних ячейки** стековой памяти. Результат операции заносится в стек.

## Логическое устройство
Информация может быть занесена в вершину стека из памяти или из АЛУ.

![[Pasted image 20231214195035.png]]

**Для выполнения арифметической** или логической операции на вход *АЛУ* подается информация, считанная *из двух верхних ячеек стека*. **Результат** операции из АЛУ **заносится в вершину** стека автоматически.

**Верхние ячейки** стековой памяти, где хранятся операнды и куда заносится результат операции, как правило, делают **более быстродействующими** и размещают в процессоре, в то время как остальная часть стека может располагаться в основной памяти и частично даже на магнитном диске.
## Резюме

**Достоинства АСК на базе стека:**
- возможность *сокращения адресной части команд* (адреса операндов и результата в командах указывать не нужно, так как все операции производятся через вершину стека);
- код программы получается *компактным*;
- *достаточно просто* реализуется декодирование команд.

**Недостатки АСК на базе стека:**
- *нет возможности произвольного доступа к памяти*, из-за чего компилятору трудно создать эффективный программный код;
- стек становится «*узким местом*» ВМ в плане повышения производительности.

Примеры стековых архитектур включают в себя `Java Virtual Machine (JVM)` и `Forth-процессоры`. Каждая из них использует стековую архитектуру для выполнения инструкций и организации данных.
<div style="page-break-after: always;"></div>

# 6. АСК. Регистровая архитектура

> [!tldr] TL:DR
> - **Регистровая архитектура**: принципы работы с массивом регистров (*РОН*).
> - **Три формата команд обработки**: *регистр-регистр*, *регистр-память*, *память-память*.
> - Операции загрузки и сохранения данных в регистрах подобны операциям с аккумулятором.
> - **Три шины между *АЛУ* и *регистровым файлом***: две для передачи операндов, третья для результата.
> - **Достоинства регистровой АСК**: компактный код, высокая скорость вычислений за счет работы с регистрами.
> - **Недостаток регистровой АСК**: более длинные команды по сравнению с аккумуляторной архитектурой.
> - **Преобладающий вид архитектуры** в современных компьютерах.
## Принципы
- Процессор включает в себя **массив РОН**. 
	- Количество РОН в архитектурах типа CISC невелико (от 8 до 32).
	- В RISC-архитектуре используется существенно большее число РОН (до нескольких сотен).
- Выделяют **три формата команд обработки**: 
	- **регистр-регистр** - «регистр-регистр» является основным в вычислительных машинах типа *RISC*.
	- **регистр-память** - команды формата «регистр-память» характерны для CISC-машин.
	- **память-память** - формат «память-память» считается неэффективным, хотя и остается в наиболее сложных моделях машин класса CISC.

Операции загрузки регистров из памяти и сохранения содержимого регистров в памяти идентичны таким же операциям с аккумулятором. Отличие состоит в этапе выбора нужного регистра, обеспечиваемого соответствующими селекторами.

![[Pasted image 20231214195727.png]]

Между *АЛУ* и *регистровым файлом* **три шины**: 
- *две обеспечивают передачу* в АЛУ операндов, хранящихся в РОН или ячейках памяти;
- *третья служит для занесения результата* в выделенный для этого регистр или ячейку памяти.
## Резюме

**Достоинства регистровой АСК:**
- *компактность* получаемого кода;
- *высокая скорость* вычислений за счет замены обращений к основной памяти на обращения к быстрым регистрам.

**Недостаток регистровой АСК:**
- требуются *более длинные команды* по сравнению с аккумуляторной архитектурой.

В наши дни этот **вид архитектуры** системы команд **является преобладающим**, в частности такую АСК имеют современные персональные компьютеры.
<div style="page-break-after: always;"></div>

# 7. АСК. Аккумуляторная архитектура

> [!tldr] TL:DR
> - **Аккумуляторная архитектура (АСК)**: операции выполняются между аккумулятором и другими регистрами.
> - **Концепт**: операнды хранятся в аккумуляторе, результат туда же сохраняется.
> - Команды для загрузки и сохранения данных в аккумуляторе.
> - **Достоинства**: короткие команды, простота декодирования.
> - **Недостатки**: многократные обращения к основной памяти.
> - Менее распространена, но может использоваться в простых системах с ограниченными ресурсами.

**Аккумуляторная архитектура (АСК)** представляет собой форму организации процессора и выполнения команд, где основная операционная структура - это **аккумулятор**. В этой архитектуре операции выполняются между аккумулятором и другими регистрами, а результат операции сохраняется обратно в аккумулятор.
## Концепт

Для хранения одного из операндов команды в процессоре **имеется выделенный регистр** — *аккумулятор*. В этот же регистр заносится и результат операции.

Поскольку **адрес** одного из **операндов предопределен**, в командах обработки достаточно явно указать местоположение только второго операнда.


![[Pasted image 20231214200052.png]]

- Для загрузки в аккумулятор содержимого ячейки x предусмотрена команда загрузки `load x` . 
- Запись содержимого аккумулятора в ячейку х осуществляется командой сохранения `store х`.
## Резюме
**Достоинства:**
- короткие команды;
- простота декодирования команд;

**Недостатки:**
- многократные обращения к основной памяти.

Аккумуляторные архитектуры, хотя и менее распространены в современных компьютерах, могут быть использованы в простых системах, где требуется небольшой объем кода и аппаратные ресурсы ограничены.
<div style="page-break-after: always;"></div>

# 8. АСК. Архитектура с выделенным доступом к памяти

> [!tldr] TL:DR
> - **Архитектура с выделенным доступом к памяти**: механизмы для выполнения операций над данными и доступа к памяти четко определены.
> - **Load/Store architecture**: доступ к памяти только через команды *load* и *store*.
> - **Операнды** в командах обработки информации могут быть только в регистрах процессора.
> - Результат операции также сохраняется в регистре, прямого обращения к памяти нет.
> - **Достоинство**: простота декодирования и исполнения команд.
> - Характерна для RISC-архитектуры.

Архитектура с выделенным доступом к памяти представляет собой форму организации процессора и памяти, в которой есть отдельные и **четко определенные механизмы** для выполнения операций над данными и **доступа к памяти**.

Операнды обязаны находится в регистрах.

**load/store architecture** - обращение к основной памяти возможно только с помощью двух специальных команд: **load** и **store**.
- *Load* обеспечивает считывание значения из основной памяти и занесение его в регистр процессора. 
- Пересылка информации в противоположном направлении производится командой *store* (сохранение).

![[Pasted image 20231224163542.png]]

В архитектуре **отсутствуют** команды обработки, **допускающие прямое обращение к основной памяти**. Допускается наличие в АСК ограниченного числа команд, где **операнд является частью кода команды.**

>[!info] Отличие от регистровой архитектуры
>Отличие от первых двух форматов регистровой архитектуры ("регистр-регистр", "регистр-память") в наличие быстрого посредника - регистра.
>
>А вот принципиальных отличий в случае "память-память" - нет. Процессы также спокойно разделяют память.

АСК с выделенным доступом к памяти характерна для всех вычислительных машин с RISC-архитектурой.
<div style="page-break-after: always;"></div>

# 9. АСК. CISC-архитектура

> [!tldr] TL:DR
> - **Проблема:** Семантический разрыв при переходе к языкам высокого уровня (ЯВУ).
> - **Решение:** CISC-архитектура (Complex Instruction Set Computer) - расширение системы команд сложными операторами, аналогичными ЯВУ.
> - **Характеристики CISC-архитектуры:**
>   - Небольшое число регистров.
>   - Многочисленные машинные команды, включая сложные операторы.
>   - Разнообразные способы адресации операндов.
>   - Множество форматов команд различной разрядности.
>   - Команды, совмещающие обработку и обращение к памяти.
> - **Негативные аспекты:** Усложнение управления, негативное влияние на производительность.
> - **Привлекательность CISC:** Универсальность, удобство программирования, эффективная обработка различных задач.

Современная технология программирования ориентирована на языки высокого уровня (ЯВУ). Но переход к ЯВУ породил серьезную проблему: семантический разрыв (сложные операторы ЯВУ существенно отличаются от простых машинных операций в ВМ).

Для разрешения проблемы выбирают один из трех типов АСК:
- архитектуру с полным набором команд: `CISC`; 
- архитектуру с сокращенным набором команд: `RISC`;
- архитектуру с командными словами сверхбольшой длины: `VLIW`.
## Определение

В **CISC-архитектуре** (Complex Instruction Set Computer) семантический разрыв преодолевается за счет расширения системы команд, **дополнения ее сложными командами**, семантически аналогичными операторам ЯВУ.

*Основоположники:* IBM, Intel.
## Характеристика

**Для CISC-архитектуры типичны: **
- наличие в процессоре *сравнительно небольшого числа регистров* общего назначения; 
- *большое количество машинных команд*, часть из которых аппаратно реализуют сложные операторы ЯВУ; 
- *разнообразие способов адресации* операндов; 
- *множество форматов команд* различной разрядности; 
- наличие команд, где *обработка совмещается с обращением к памяти*.

Этот способ решения проблемы семантического разрыва вместе с тем ведет к усложнению аппаратуры ВМ, главным образом, устройства управления, что, в свою очередь, негативно сказывается на производительности ВМ в целом.

CISC-архитектура, остается привлекательной из-за своей универсальности, удобства программирования и способности эффективно обрабатывать разнообразные задачи.
<div style="page-break-after: always;"></div>

# 10. АСК. RISC-архитектура

> [!tldr] TL:DR
> - **RISC** (Reduced Instruction Set Computing) - архитектура процессора для повышения производительности через упрощенные и часто используемые команды.
> - *Основоположник*: Cray Research.
> - *Команды работают* с данными только в *регистрах* процессора.
> - Используются *специальные команды* для обращения к памяти.
> - **Уменьшено количество форматов команд** и способов указания адресов операндов.
> - Это **упростило аппаратные средства ВМ** и улучшило быстродействие.
> - Пример RISC-процессора: **ARM** в мобильных устройствах.

**RISC** (Reduced Instruction Set Computing) - это архитектура процессора, которая **характеризуется упрощенным набором команд**, нацеленным на повышение производительности и эффективности исполнения инструкций. Рассмотрим основные аспекты RISC-архитектуры.

*Основоположник*: Cray Research.

Идея **RISC-архитектуры** заключается в ограничении списка команд ВМ наиболее часто используемыми простейшими командами.
- *Команды оперируют* данными, размещенными только в *регистрах* процессорах.
- Обращение к памяти допускается лишь с помощью *специальных команд чтения и записи*.
- **Резко уменьшено количество форматов команд** и способов указания адресов операндов.

Эти меры позволили **существенно упростить аппаратные средства** ВМ и повысить их быстродействие.

В последнее время в микропроцессорах компаний Intel и AMD широко используются идеи, свойственные RISC-архитектуре, так что многие различия между CISC и RISC постепенно стираются

Примеры RISC-процессоров: **ARM** в мобильных устройствах
<div style="page-break-after: always;"></div>

# 11. АСК. VLIW-архитектура

> [!tldr] TL:DR
> - **VLIW** (Very Long Instruction Word) - разновидность RISC-архитектуры, параллельное выполнение команд без динамического выделения.
> - Концепция VLIW-архитектуры **базируется на RISC**, где простые RISC-команды объединяются в одну сверхдлинную команду и выполняются параллельно.
> - В плане АСК VLIW мало отличается от RISC, с **добавлением уровня параллелизма** вычислений.
> - Архитектуру VLIW логичнее ассоциировать с вычислительными системами, чем с вычислительными машинами.

**VLIW** (Very Long Instruction Word) - это архитектура процессора, которая представляет собой разновидность RISC-архитектуры. Однако, в отличие от RISC, VLIW осуществляет параллельное выполнение инструкций без динамического выделения. Рассмотрим основные аспекты VLIW-архитектуры:

Концепция **VLIW-архитектуры** (архитектура с командными словами сверхбольшой длины) **базируется на RISC**-архитектуре, но в ней несколько простых RISC-команд **объединяются в одну сверхдлинную команду** *и выполняются параллельно*. В абстракции команды описываются так.

```VLIW
f12 = f0 * f4, f8 = f8 + f12, f0 = dm(i0, m3), f4 = pm(i8, m9);
```

В плане АСК архитектура VLIW **сравнительно мало отличается от RISC**. Появился лишь дополнительный уровень параллелизма вычислений, в силу чего архитектуру VLIW логичнее адресовать не к вычислительным машинам, а **к вычислительным системам**.
<div style="page-break-after: always;"></div>

# 12. Типы и форматы данных. Числа с фиксированной запятой

> [!tldr] TL:DR
> - **Числа с фиксированной запятой** (Fixed-Point Numbers) - формат данных для представления чисел с постоянным числом разрядов после запятой.
> - Используется во встраиваемых системах для предсказуемости и управления объемом памяти.
> - В отличие от чисел с плавающей запятой, **числа с фиксированной запятой имеют постоянное количество десятичных разрядов**.
> - **Представление числа в форме с фиксированной запятой**: $$A = \pm a_{n-1} \ldots a_1 a_0 a_{-1} a_{-2} \ldots a^{-r}$$
> - **Отрицательные числа часто представляются в дополнительном коде**.
> - **Положение запятой остается неизменным** для всех чисел, что упрощает аппаратную реализацию вычислительных устройств и ускоряет операции.
> - Если число смешанное, обрабатывается как масштабируемое целое.
> - Эффективен для аппаратной реализации и ускорения машинных операций в вычислительных системах.

## Типы и форматы данных*

**Операнды** – *данные*, которыми оперируют машинные команды.

**Базовые типы операндов: 
- числа; 
- символы;
- логические данные. 

**Сложные информационные единицы:**
- графические изображения;
- аудио-, видео и анимационная информация.

---
## Числа с фиксированной запятой

**Числа с фиксированной запятой** (Fixed-Point Numbers) представляют собой формат данных, который используется для представления чисел с фиксированным числом разрядов после запятой. В отличие от чисел с плавающей запятой, у чисел с фиксированной запятой количество десятичных разрядов остается постоянным. Этот формат данных часто используется во встраиваемых системах, где **важна предсказуемость и управление занимаемым объемом памяти**.

Представление чисел в форме с фиксированной запятой (ФЗ) является одним из распространенных методов в вычислительной технике. Число A в форме с ФЗ **состоит из знака числа и его модуля, представленного в q-ричном коде**, где q - основание системы счисления. В данном контексте, для современных вычислительных машин характерна двоичная система (q = 2), хотя также могут использоваться восьмеричная (q = 8) или шестнадцатеричная (q = 16) системы счисления.

Число A в форме ФЗ записывается следующим образом: $$A = \pm\;a_{n-1} \ldots a_1 \,a_0\,a_{-1}\,a_{-2} \ldots a^{-r}$$, где $a_i$ - цифры числа, индекс $i$ указывает на разряды числа, и знак числа представлен знаковым разрядом кода.

**Отрицательные числа**, как правило, **представляются в дополнительном коде**, что обеспечивает удобство операций сложения и вычитания. **Знаковый разряд** кода содержит информацию о знаке числа, в то время как цифровые разряды кода содержат значащие цифры.

Одно из важных свойств представления чисел в формате ФЗ заключается в том, что **положение запятой остается неизменным** для всех чисел в процессе решения задач. Это облегчает аппаратную реализацию вычислительных машин и ускоряет выполнение машинных операций.

Если число является **смешанным** (содержит как целую, так и дробную части), оно обрабатывается как масштабируемое целое. Обычно используются вычислительные машины с дробной (n ≠ 0) или целочисленной (r ≠ 0) арифметикой.

Такой подход к представлению чисел в форме с фиксированной запятой упрощает аппаратную реализацию вычислительных устройств и сокращает время выполнения машинных операций, что является ключевым аспектом при проектировании и оптимизации вычислительных систем.

>[!example] Пример
> У нас есть 8 бит для представления числа с фиксированной запятой (Q4.4). Тогда, у нас будет 4 бита для целой части и 4 бита для дробной части. Например, число $5.75$ в таком формате будет представлено как $0101.1100$.
<div style="page-break-after: always;"></div>

# 13. Типы и форматы данных. Числа с плавающей запятой

> [!tldr] TL:DR
> - **Числа с плавающей запятой** (Floating-Point Numbers) - формат данных для представления вещественных чисел с десятичной запятой.
> - Обеспечивает **более широкий диапазон значений и большую точность** по сравнению с форматом с фиксированной запятой.
> - Формула для числа с плавающей запятой: $(-1)^s \times M \times B^E$, где B - основание системы счисления (чаще всего 2).
> - Стандарт IEEE 754 предоставляет два формата: одинарной точности (32 бита) и двойной точности (64 бита), обеспечивая разную точность для различных задач.

**Числа с плавающей запятой** (Floating-Point Numbers) представляют собой формат данных, который используется для представления вещественных чисел, включая числа с десятичной запятой. Этот формат обеспечивает **более широкий диапазон значений и большую точность**, чем формат с фиксированной запятой. Рассмотрим основные характеристики чисел с плавающей запятой:

Числа в форме с плавающей запятой представляют собой важный аспект в области вычислительных технологий. Такое представление числа **включает в себя знак, порядок и мантиссу**, обозначаемые соответственно как s, E и M. Формула для числа с плавающей запятой выглядит следующим образом:
$$(-1)^s \times 1.M \times B^E$$
где B - основание системы счисления

**Мантисса** представляет собой целое число фиксированной длины и содержит **старшие разряды** действительного числа. В нормализованном представлении первый бит мантиссы всегда положителен, что позволяет экономить один бит.

>[!info] Пример
>По сути мантисса представляет собой само число, а $E$ - число знаков на которое нужно сместить запятую, тоесть для примера:
>$7.25_{10}=111.01_2$
>или при записи в формате IEEE 754
>$(-1)^s \times 1.M \times B^E=1.1101\cdot10^2$, где $M=1101$, а $E=2$

Порядок определяет степень базы старшего разряда. По стандарту IEEE 754, числа с плавающей запятой **представляются в двух форматах**:

1. **Одинарной точности** (float) - 32 бита, из которых 23 бита представляют мантиссу, и 8 бит смещенного порядка (E' = E + 127).

2. **Двойной точности** (double) - 64 бита, из которых 52 бита представляют мантиссу, и 11 бит смещенного порядка (E' = E + 1023).

Эти форматы обеспечивают представление чисел с разной точностью, что важно для различных вычислительных задач. Стандарт IEEE 754 обеспечивает единый формат чисел с плавающей запятой, что упрощает их обработку и обмен между различными вычислительными устройствами.

![[Pasted image 20231214213304.png]]

<div style="page-break-after: always;"></div>

# 14. Типы и форматы данных. BCD-числа

> [!tldr] TL:DR
> - **BCD** (Binary Coded Decimal) - формат представления десятичных чисел в двоичной системе с использованием 4 бит для каждой цифры.
> - Каждая тетрада **может принимать значения** от $0000_2$ ($0_{10}$) до $1001_2$ ($9_{10}$), исключая двоичные комбинации без эквивалента в десятичной системе.
> - **Преимущества**:
>   - Удобно для индикаторов с одной цифрой, например, в часах.
>   - Упрощенный вывод на индикацию и ввод с цифровой клавиатуры.
>   - При переводе дробных чисел точность не теряется.
>   - Упрощены умножение, деление на 10 и округление.
> - **Недостатки**:
>   - Требует больше памяти.
>   - Усложнены арифметические операции.
> - **Операции**:
>   - При сложении и вычитании чисел формата 8421-BCD применяются коррекционные значения для обработки переносов и недопустимых комбинаций.

**BCD** (Binary Coded Decimal) - это формат представления десятичных чисел в двоичной системе счисления. Каждая десятичная цифра кодируется отдельно **с использованием 4 бит**, *исключая двоичные комбинации, которые не имеют эквивалента в десятичной системе*. Таким образом, каждая тетрада двоично-десятичного числа может принимать значения от $0000_2$ ($0_{10}$) до $1001_2$ ($9_{10}$).

> [!example] Пример
> Десятичное число $311_{10}$ будет записано в двоичной системе счисления в двоичном коде как $100110111_2$, а в двоично-десятичном коде как $0011\:0001\:0001_{BCD}$.
## Преимущества
- Удобно использовать для вывода на индикаторы с одной цифрой. Например, в часах каждый индикатор отображает десятичное число в двоично-десятичной системе (**от 0 до 9**).
- Упрощён вывод чисел на индикацию - вместо последовательного деления на 10 требуется просто вывести на индикацию каждый полубайт. По этой же причине проще ввод данных с цифровой клавиатуры.
- Для дробных чисел (как с фиксированной, так и с плавающей запятой) при переводе в человекочитаемый десятичный формат и наоборот **не теряется точность**.
- Упрощены умножение и деление на 10, а также округление.
## Недостатки
- Требует больше памяти.
- Усложнены арифметические операции.
## Операции
При сложении и вычитании чисел формата 8421-BCD действуют следующие правила:
- При сложении двоично-десятичных чисел каждый раз, когда происходит перенос бита в старший полубайт, необходимо к полубайту, от которого произошёл перенос, добавить **корректирующее значение** $0110_2=6_{10}=16_{10}—10_{10}$: разница количеств комбинаций полубайта и используемых значений).
- При сложении двоично-десятичных чисел каждый раз, когда встречается недопустимая для полубайта комбинация (число, большее 9), необходимо к каждой недопустимой комбинации **добавить корректирующее значение** $0110_2$ с разрешением переноса в старшие полубайты. 
- При вычитании двоично-десятичных чисел, для каждого полубайта, получившего заём из старшего полубайта, необходимо провести коррекцию, **отняв значение** $0110_2$.
<div style="page-break-after: always;"></div>

# 15. Типы и форматы данных. Символьная информация, логические данные, строки

> [!tldr] TL:DR
> - **Символьная информация**:
>   - Каждому символу соответствует определенная двоичная комбинация, образующая таблицу кодировки.
>   - Принцип весов: веса кодов цифр возрастают, а веса символов увеличиваются в алфавитном порядке.
>   - **Кодовые таблицы**:
>     1. **EBCDIC** (Extended Binary Coded Decimal Interchange Code).
>     2. **ASCII** (American Standard Code for Information Interchange).
>     3. **Unicode (UCS)** - 8-разрядные (256 символов) и 16-разрядные (65536 символов).
> - **Логическая информация**:
>   - Элемент - булева переменная с двумя значениями: "истина" (1) или "ложь" (0).
>   - В виртуальных машинах операции с логическими переменными обычно ведутся наборами длиной в машинное слово.
> - **Строки**:
>   - Непрерывная последовательность битов, байтов, слов или двойных слов.
>   - Длина может варьироваться от 0 до 4 Гбайт.
>   - Текстовая строка - байты байтовой строки представляют собой коды символов.
> - **Прочие виды информации**:
>   - **Статическая** - числовая, символьная и логическая, видеоинформация.
>   - **Динамическая** - аудиоинформация, видео- и анимационные фильмы.
## Символьная 
Каждому символу **ставится в соответствие** определенная двоичная комбинация. Совокупность возможных символов и назначенных им двоичных кодов образует **таблицу кодировки**.

Общий принцип для различных таблиц кодировки: веса кодов цифр возрастают по мере увеличения цифры, а веса символов увеличиваются в алфавитном порядке.

### Кодовые таблицы
1) Расширенный двоично-кодированный код **EBCDIC** (Extended Binary Coded Decimal Interchange Code), он же ДКОИ (двоичный код для обработки информации);
2) Американский стандартный код для обмена информацией **ASCII** (American Standard Code for Information Interchange);
3) Универсальный набор символов *UCS* (Universal Character Set), он же **Unicode**. Первый и второй коды – символы кодируются с помощью 8-разрядных комбинаций (256 различных символов). Третий код - символы кодируются с помощью 16-разрядных комбинаций (65536 различных символов). **Unicode обратно совместим с кодировкой ASCII.**

## Логические
Элемент - логическая (булева) переменная, которая может принимать лишь **два значения**: «истина» или «ложь». 
Кодирование логического значения принято осуществлять битом информации: 
- **1 - истинное значение**;
- **0 — ложное**. 
Как правило, в виртуальных машинах оперируют наборами логических переменных длиной в машинное слово.
## Строки
Строки — это **непрерывная последовательность** битов, байтов, слов или двойных слов. Битовая строка может начинаться в любой позиции байта и содержать до 232 битов. Байтовая строка может состоять из байтов, слов или двойных слов. Длина такой строки варьируется от нуля до 4 Гбайт. 
Текстовая строка - байты байтовой строки представляют собой коды символов.
## Прочие виды информации
Представляемая в виртуальной машине информация может быть:
- **Статической** - числовая, символьная и логическая, видеоинформация (текст, рисунки, графики, чертежи, таблицы, слайд-фильмы и др.);
- **Динамической** – аудиоинформация, видео- и анимационные фильмы.
<div style="page-break-after: always;"></div>

# 16. Типы и форматы данных. Видео- и аудиоинформация

> [!tldr] TL:DR
> - **Аудиоинформация:**
>  - Частоты аудиосигналов: 15 Гц - 20 кГц, **аналоговые по природе**.
>  - В виртуальной машине аудиоинформация **оцифровывается с помощью АЦП** и воспроизводится **обратно с использованием ЦАП**.
> - Рекомендуется **16-разрядное представление амплитуды** сигнала и частота выборки порядка **40 кГц**.
>
> - **Видеоинформация:**
> 	- Используется для передачи **движущихся изображений** (анимация).
> 	- Существуют **два способа представления** графических изображений: матричный (растровый) и векторный.
> 	 - **Матричный (растровый):**
>		- Изображение представляется **матрицей пикселов**.
>		- Недостаток: большая емкость памяти, требуемая для хранения изображения.
> 	 - **Векторный:**
> 		 - Изображение задается **графическими примитивами, описываемыми математически формулами**.
> 		 - Достоинства: сокращение объема файла и сохранение качества при масштабировании.
> 		 - Недостаток: искусственность изображений и низкая производительность.

## Аудиоинформация
Аудиоинформация в мультимедийных системах технологически обычно представляется в виде _**аудиоряда**_, то есть **последовательности значений амплитуды звукового давления**, записанных в цифровой форме.

Частоты аудиосигналов лежат в диапазоне от 15 Гц до 20 кГц, **сигналы** по своей природе непрерывные (**аналоговые**). 

В виртуальной машине аудиоинформация должна быть оцифрована: выборки (samples) с помощью АЦП переводятся в двоичный код. **Обратное действие выполняется ЦАП**.

Для высококачественного представления аудиоинформации рекомендуется **16-разрядное представление амплитуды** сигнала ($2^{16}$ градаций уровня звука) и частота выборки порядка 40 кГц (промежуток времени между последовательными выборками не более 25 мкс). 

>[!example] Форматы хранения
> AVI, WAV, MIDI, AIF, MPEG.
## Видеоинформация
Динамическая видеоинформация используется для **передачи движущихся изображений (анимация)**. В основе - последовательное **экспонирование** на экране в реальном масштабе времени отдельных кадров в соответствии со сценарием.

Существует два способа представления графических изображений:

1) **Матричный** (растровый) - для изображений со сложными гаммами цветов, оттенков и форм. Изображение **представляется прямоугольной матрицей точек — пикселов**, положение которых в матрице соответствует координатам точек на экране. Каждый пиксел характеризуется своим цветом, цветом фона или градацией яркости. **Недостаток** - большая емкость памяти, требуемая для хранения изображения, из-за чего для описания изображений прибегают к различным методам сжатия данных. 

>[!example] Пример
> - Форматы: BMP, GIF, PCX, JPEG, TIFF, PNG.
>  - Аудиокодек: MPEG Audio Layer III
>  - Битрейт: 256 kbps
>  - Частота дискретизации: 44.1 kHz

2) **Векторный** - для чертежей и изображений с простыми формами, тенями и окраской. Изображение **задается графическими примитивами**, которые могут быть описаны математически (линии и ломаные линии, многоугольники, окружности и эллипсы, сплайны, безигоны). Для их описания достаточно указать лишь несколько параметров, а соответствующее графическое представление получить путем вычислений. **Достоинства** - существенное сокращение объема файла с изображением и сохранение качества изображения при масштабировании объектов. **Недостаток** - некоторая искусственность изображений и низкая производительность. 

>[!example] Пример
> - Форматы: DXF, CDR, AI, PS, SVG, VSD.
> - Видеокодек: H.264
> - Разрешение: 1920x1080
> - Кадров в секунду: 30 fps
<div style="page-break-after: always;"></div>

# 17. Сложные структуры данных. Особенности их обработки


>[!warning] Важно
> В презентациях про это ничего нет. Угадывай мысли Семененко)

## Массив
Cамый простой способ хранения набора элементов в памяти компьютера. Происходит выделение единого пространства в памяти и последовательной записи элементов.
- Каждый элемент в массиве занимает такой же объем памяти, что и любой другой.
- Можно напрямую обращаться к любому элементу массива.
- Полезен для реализации стека, списков и очередей.
НО:
- Может оказаться нецелесообразно выделять большие и непрерывные блоки памяти.
- При использовании динамического массива может оказаться, что рядом достаточной свободной памяти нет.
- Удаление или вставка элемента из середины массива требует сдвига всех последующих элементов на одну позицию.
## Связанный поиск
Связный список (linked list) позволяет хранить элементы в цепи ячеек, которые не обязательно должны находиться в последовательных адресах памяти.
- Память выделяется по мере необходимости.    
- Каждая ячейка имеет адрес, сообщающий об адресе следующей ячейки в цепи.   
- Ячейка с пустым указателем отмечает конец такой цепочки.
- При наращивании списка не возникает никаких проблем: любая ячейка может храниться в любой части памяти.
- т.е. размер списка ограничен только объемом имеющейся свободной памяти
НО:
- Не можем получить сразу i-тый элемент. Нужно последовательно пройти по цепочке элементов до искомого элемента.
    
## Двусвязный список
Двусвязный список (double linked list) – связный список, где ячейки имеют два указателя: на предыдущую ячейку и на следующую.
- Преимущества те же, что и у связного списка. 
- При этом есть возможность передвигаться как «вперед» по списку, так и «назад».  
- Но по-прежнему сразу же доступ к i-тому элементу не получить. 
## Хеш-таблица
Хеш-таблица (hash table) – структура данных, которая позволяет находить элементы со сложностью алгоритма О(1).
- Требуется предварительное выделение большого блока последовательной памяти. Но в отличие от массива, позиция элемента определяется хеш-функцией.
- ﻿﻿Хеш-функция - это специальная функция, которая на входе получает данные, предназначенные для хранения, и возвращает число, которое интерпретируется как позиция в памяти, куда будет помещен элемент.
- ﻿﻿НО! Иногда хеш-функция возвращает одинаковую позицию для разных входных данных. Это хеш-коллизия. В этом случае необходимо такие элементы должны быть сохранены в одной позиции хеш-таблицы.

## Дерево
Дерево (tree) использует элементы, которым для хранения объектов не нужно располагаться в физической памяти непрерывно.
- Деревья удобны для иерархических данных.
- ﻿﻿Ячейка называется узлом, указатель из одной ячейки на другую - ребром. Самая первая ячейка - это корневой узел.
- ﻿﻿Узлы, не имеющие дочерних узлов - листья.
- ﻿﻿Путь между двумя узлами определяется множеством узлов и ребер.
- ﻿﻿Уровень узла - это длина пути от узла до корневого узла в дереве.
- ﻿﻿Множество деревьев называется лесом.

### Двоичное дерево поиска
Двоичное дерево поиска (binary search tree) – тип дерева, поиск в котором исполняется особенно эффективно.
- Узлы в двоичном дереве могут иметь не более двух дочерних узлов.
- ﻿﻿Дочерние узлы слева от родителя должны быть меньше него, а справа ﻿﻿больше.
### Двоичная куча
Двоичная куча (binary heap) -  особый тип двоичного дерева поиска, в котором можно мгновенной найти самый маленький (или самый большой) элемент.

Правила размещения элементов те же, что и двоичные деревья поиска, но есть одно ограничение: родительский узел должен быть меньше (либо больше) обоих своих дочерних узлов.

## Граф
Во многом аналогичен дереву.

Данные организованы в виде узлов (вершин) и дуг (ребер) так, что любой узел может иметь произвольное число входящих и исходящий ребер.
<div style="page-break-after: always;"></div>

# 18. Функциональная классификация команд
- [[#Команды пересылки данных]] - Эти команды обеспечивают передачу информации между процессором и оперативной памятью, внутри процессора и между ячейками памяти.
- [[#Арифметико-логические команды]] - арифмитические и логические операции с байтами;
- [[#SIMD-команды]] - SIMD-команды предназначены для выполнения одной и той же операции над несколькими элементами данных одновременно. 
- [[#Команды для работы со строками]] - Эти команды обеспечивают перемещение, сравнение и поиск строк. В большинстве ВМ перечисленные операции просто имитируются за счет других команд.
- **Команды преобразования** - преобразование одних типов данных к другому.
- [[#Команды ввода/вывода]] - команды для обращения с периферией.
- [[#Команды управления потоком команд]] - изменяют естественный порядок следования и передают управление в иную точку программы. ;
- [[#Команды управления системой]] - команды являются привилегированными и могут выполняться только когда центральный процессор ВМ находится в привилегированном состоянии или выполняет программу, находящуюся в привилегированной области памяти.
<div style="page-break-after: always;"></div>

# 19. Машинные команды. Арифметико-логические команды и команды сдвига

> [!tldr] TL:DR
> - **Машинные команды:** Основные операции в машинном языке, включая арифметико-логические и команды сдвига.
> - **Арифметико-логические команды:** Обеспечивают арифметическую и логическую обработку информации, сопровождаются признаками, такими как Z, N, V, C.
>   - **Операции с целыми числами:** Двухместные (сложение, вычитание, умножение, деление), одноместные (абсолютное значение, изменение знака), операции сравнения.
>   - **Операции с числами в форме с плавающей запятой:** Арифметические (сложение, вычитание, умножение, деление), операции сравнения, преобразование формы и формата представления.
> - **Команды сдвига:** Реализуют логический, арифметический и циклический сдвиг.

**Машинные команды**, в частности арифметико-логические (ALU) и команды сдвига, представляют собой **основные операции в машинном языке**, выполняемые арифметическим и логическим устройством процессора. 
## Арифметико-логические команды:
В данную группу входят команды, **обеспечивающие арифметическую и логическую обработку** информации в различных формах ее представления. Выполнение арифметических и логических операций сопровождается формированием в АЛУ признаков (**флагов**), характеризующих этот результат.

**Наиболее часто фиксируются такие признаки, как:**
- Z (Zero) — нулевой результат;
- N (Negative) — отрицательный результат;
- V (oVerflow) — переполнение разрядной сетки;
- C (Carry) — наличие переноса.
### Операции с целыми числами
- **Двухместные арифметические операции** (операции с двумя операндами): сложение, вычитание, умножение и деление;
- **Одноместные арифметические операции** (операции с одним операндом): вычисление абсолютного значения (модуля) операнда, изменение знака операнда;
- **Операции сравнения**, обеспечивающие сравнение двух целых чисел и выработку признаков, характеризующих соотношение между сопоставляемыми величинами (=, <>, >, <=, >=).
### Операции с числами в форме с плавающей запятой
- **Основные арифметические операции**: сложение, вычитание, умножение и деление;
- **Операции сравнения** с выработкой признаков: =, <>, >, <=, >=;
- **Операции преобразования** формы представления (между фиксированной и плавающей запятой), формата представления (с одинарной и двойной точностью).
### Примеры команд
1. **Сложение (ADD):** Складывает значения из двух регистров и сохраняет результат в одном из них.
2. **Умножение (MUL):** Умножает значения из двух регистров и сохраняет результат в одном из них.
3. **Логическое И (AND):** Выполняет логическое И для битов в двух регистрах и сохраняет результат.
4. **Логическое исключающее ИЛИ (XOR):**  Выполняет логическое исключающее ИЛИ для битов в двух регистрах и сохраняет результат.
## Команды сдвига:
Практически во всех АСК предусмотрены команды для реализации операций логического, арифметического и циклического сдвигов.

![[Pasted image 20231214215353.png]]
### Примеры команд
1. **Логический сдвиг влево (SHL или SAL - арифметический сдвиг влево):** Сдвигает биты влево на указанное количество позиций, добавляя нули в освободившиеся позиции.
2. **Арифметический сдвиг вправо (SAR):**  Сдвигает биты вправо на указанное количество позиций, копируя старший бит (знаковый бит) для сохранения знака числа.
3. **Ротация влево (ROL):** двигает биты влево на указанное количество позиций, при этом старшие биты переносятся в младшие.
<div style="page-break-after: always;"></div>

# 20. Машинные команды. Команды пересылки и команды ввода-вывода

> [!tldr] TL:DR
> - **Команды ввода/вывода:** *обмен информацией* с ПУ.
>     - Команды ввода: Получение данных от ПУ и передача их на шину данных.
>     - Команды вывода: Прием данных с шины данных и отправка на ПУ.
> - **Команды пересылки данных:**
>   - Передача информации между процессором и оперативной памятью, внутри процессора и между ячейками памяти.
>   - *Содержат* информацию об адресах источника и получателя, длине данных и способе адресации операндов.
## Команды ввода/вывода
Команды этой группы делятся на:
- **Команды управления периферийным устройством (ПУ)** — *запуск ПУ* и указания ему требуемого действия;
- **Проверки состояния ввода/вывода** — тестирование различных признаков, *характеризующих состояние* модуля В/ВЫВ и подключенных к нему ПУ;
- **Ввода и вывода** — *обеспечение обмена информацией* с ПУ (команды ввода предписывают модулю В/ВЫВ получить элемент данных от ПУ и поместить его на шину данных, а команды вывода — заставляют модуль В/ВЫВ принять элемент данных с шины данных и переслать его на ПУ).
### Пример команд:
1. **IN (Input):** Считывает данные из внешнего устройства (например, порта ввода) и помещает их в регистр.
2. **OUT (Output):** Передает данные из регистра во внешнее устройство (например, порт вывода).
## Команды пересылки данных
Эти команды обеспечивают передачу информации между процессором и оперативной памятью, внутри процессора и между ячейками памяти.
**В таких командах должна содержаться следующая информация:**
- Адреса источника и получателя операндов;
- Длина подлежащих пересылке данных, заданная явно или косвенно;
- Способ адресации каждого из операндов.
### Пример команд
1. **MOV (Move):**  Копирует данные из одного регистра или ячейки памяти в другой.
2. **LDR (Load Register):**  Загружает данные из памяти по указанному адресу в регистр.
3. **STR (Store Register):** Сохраняет данные из регистра в память по указанному адресу.
4. **LDM (Load Multiple):** Загружает несколько значений из последовательных ячеек памяти в регистры.
5. **STM (Store Multiple):** Сохраняет несколько значений из регистров в последовательные ячейки памяти.
<div style="page-break-after: always;"></div>

# 21. Машинные команды. SIMD-команды. Команды работы со строками

> [!tldr] TL:DR
> - **SIMD-команды:**
>   - SIMD-команды реализуют **параллельную обработку** двух **групп чисел** с использованием упакованных форматов, ускоряя вычисления над мультимедийными данными.
>   - Первые SIMD-команды **выполняют арифметические операции** над упакованными целыми числами с арифметикой с насыщением.
>   - Более поздние SIMD-команды обрабатывают также операнды в упакованных числах с плавающей запятой.
> 
> - **Команды для работы со строками:**
>   - Обеспечивают перемещение, сравнение и поиск строк.
>   - Операции, такие как MOVS, LODS и REP, выполняют копирование, загрузку и управление повторениями соответственно.

## SIMD-команды
**Single Instruction Multiple Data** — «одна команда — много данных». SIMD-команды **обрабатывают** сразу две **группы чисел** (групповые команды). Операнды таких команд обычно представлены в одном из упакованных форматов. SIMD-команды позволяют существенно ускорить вычисления над мультимедийными данными.

Первые из этих команд обеспечивали параллельную обработку упакованных целых чисел. При выполнении арифметических операций каждое из чисел, входящих в группу, рассматривается как самостоятельное, без связи с соседними числами. Эти **команды реализуют так называемую арифметику с насыщением**: если в результате сложения образуется число, выходящее за пределы отведенных под него позиций, оно заменяется наибольшим двоичным числом, которое в эти позиции вмещается.

Следующие наборы SIMD-команд стали иметь возможность работать также с операндами, представленными в виде упакованных чисел с плавающей запятой.

![[Pasted image 20231214215558.png]]

### Пример команд
1. **SSE (Streaming SIMD Extensions) команды:** SSE включает команды для арифметических и логических операций над векторами одиночной точности (float) и двойной точности (double).

   ```assembly
   ; Пример SSE команды сложения векторов одиночной точности
   ADDPS xmm1, xmm2, xmm3  ; xmm1 = xmm2 + xmm3
   ```

2. **AVX (Advanced Vector Extensions) команды:** AVX расширяет возможности SIMD с поддержкой широких векторов (256 бит и 512 бит).

   ```assembly
   ; Пример AVX команды сложения векторов одиночной точности
   VADDPS ymm1, ymm2, ymm3  ; ymm1 = ymm2 + ymm3
   ```

## Команды для работы со строками
Эти команды обеспечивают перемещение, сравнение и поиск строк.
В большинстве ВМ перечисленные операции просто имитируются за счет других команд.

### Пример команд
1. **MOVS (Move String):** Копирует последовательность байтов из одного места в другое (например, из памяти в память). Используется для копирования строк.

   ```x86
   ; Копирование байта из DS:[ESI] в ES:[EDI] и инкремент индексов
   MOVS EDI, ESI 
   ```

2. **LODS (Load String):** Загружает байт или слово из строки в регистр. Используется для считывания данных из строки.

   ```x86
   ; Загрузка байта из DS:[ESI] в AL и инкремент индекса ESI
   LODS AL, BYTE PTR DS:[ESI]
   ```

3. **REP (Repeat):**  Управляющая команда, используемая с другими строковыми командами для указания количества повторений.

   ```x86
   ; Повторяет MOVS до тех пор, пока счетчик ECX не станет нулем
   REP MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI]
   ```
<div style="page-break-after: always;"></div>

# 22. Машинные команды. Команды передачи управления

> [!tldr] TL:DR
> - **Команды управления потоком команд изменяют естественный порядок выполнения** и передают управление в другую точку программы. Три разновидности команд включают безусловные и условные переходы (ветвления) и вызовы процедур с возвратами.
> - **Команды безусловного перехода обеспечивают переход** по заданному адресу без проверки условий.
> - **Условные переходы** происходят при соблюдении определенного условия, иначе выполняется следующая команда программы.
> - **Команды вызова процедур** и возврата из процедур реализуют процедурный механизм, позволяя переходить к началу процедуры и возвращаться из нее.
> - **Команды управления системой** являются привилегированными и выполняются только в привилегированном состоянии процессора или при выполнении программы в привилегированной области памяти. Эти команды управляют системными ресурсами, такими как чтение и изменение состояния регистров устройства управления.
## Команды управления потоком команд
Команды **изменяют естественный порядок следования** и передают управление в иную точку программы. В адресной части таких команд содержится адрес точки перехода. Переход реализуется путем загрузки адреса точки перехода в счетчик команд (вместо увеличения содержимого этого счетчика на длину команды).

**Три разновидности команд:**
1. Безусловные переходы;
2. Условные переходы (ветвления);
3. Вызовы процедур и возвраты из процедур.

### 1. Команды безусловного перехода
Команда безусловного перехода (**jump**) обеспечивает переход по заданному адресу **без проверки каких-либо условий**. 

   ```x86
   ; Пример безусловного перехода (x86)
   JMP label_name
   
   ; Пример перехода по адресу в регистре (x86)
   JMP EAX
   ```

### 2. Условные переходы (ветвления)
Условный переход (**branch**) происходит **только при соблюдении определенного условия**, в противном случае выполняется следующая по порядку команда программы. 

  ```x86
   ; Переход, если флаг равенства установлен
   JE label_name
   ```
   
Условия для перехода: **признаки** результата предшествующей операции, которые **фиксируются в соответствующих разрядах регистра** признаков процессора; состояние одного из РОН, куда помещается результат операции сравнения; объединение операций сравнения и перехода в одной команде. Одна из форм команд условного перехода - команды пропуска.

### 3. Вызовы процедур и возвраты из процедур
Команды вызова процедуры и возврата из процедуры **реализуют процедурный механизм**.

   ```assembly
   ; Пример вызова подпрограммы (x86)
   CALL subroutine_name
   
   ; Пример возврата из подпрограммы (x86)
   RET
   ```
   
Команды вызова процедуры обеспечивают переход из текущей точки программы к начальной команде процедуры. Команды возврата из процедуры используются для возврата в точку, непосредственно расположенную за командой вызова. Такой режим предполагает наличие средств для сохранения текущего состояния содержимого счетчика команд в момент вызова (запоминание адреса точки возврата) и его восстановления при выходе из процедуры.
## Команды управления системой
Эти команды являются привилегированными и могут выполняться только когда центральный процессор ВМ находится в привилегированном состоянии или выполняет программу, находящуюся в привилегированной области памяти. Например, лишь эти команды способны считывать и изменять состояние ряда регистров устройства управления.
<div style="page-break-after: always;"></div>

# 23. Представление команд в ЭВМ. Форматы команд

> [!tldr] TL:DR
> - **Типовая команда** содержит **операционную и адресную части**, определяющие операцию и адреса операндов и результата.
> - **Формат команды** определяет структуру через количество двоичных разрядов, отведенных под всю команду, и расположение полей.
> - Выбор формата команды влияет на **характеристики машины**, включая количество команд, общую длину, типы полей, простоту декодирования, адресуемость и стоимость оборудования.
> - **Длина команды** важна для организации памяти, структуры шин, сложности и быстродействия ЦП; часто выбирается кратной байту.
> - **Общая длина команды** RK определяется количеством адресов, их разрядностью, разрядностью кода операции и способа адресации.

**Типовая команда должна указывать:**
- Подлежащую выполнению операцию;
- Адреса исходных данных (операндов), над которыми выполняется операция;
- Адрес, по которому должен быть помещен результат операции.

В соответствии с этим команда состоит из двух частей: **операционной и адресной**. В состав кода команды вводится поле для задания способа адресации (СА):
$$КОП\quadСА\quadАдресная\;часть.$$
Формат команды определяет ее структуру - количество **двоичных разрядов, отводимых под всю команду**, а также количество и расположение отдельных полей команды. Поле — совокупность двоичных разрядов, кодирующих составную часть команды.

Выбор формата команды влияет на многие характеристики будущей машины, при этом **нужно учитывать следующие факторы**:
- Общее число различных команд;
- Общую длину команды;
- Тип полей команды (фиксированной или переменной длины) и их длина;
- Простоту декодирования;
- Адресуемость и способы адресации;
- Стоимость оборудования для декодирования и исполнения команд.
## Длина команды

Это важнейшая характеристика, влияющая на организацию и емкость памяти, структуру шин, сложность и быстродействие ЦП. Для упрощения аппаратуры и повышения быстродействия ВМ **длину команды обычно выбирают кратной байту**. В рамках системы команд одной ВМ могут использоваться разные форматы команд. Обычно это связано с применением различных способов адресации.

Общая длина команды RK может быть описана следующим соотношением:
$$Общая\;длина\;команды\;RK = l \cdot RАi+RКОП+RСА$$
где 
- $l$ — количество адресов в команде; 
- $RA_i$ — количество разрядов для записи i-го адреса; 
- $RКОП$ — разрядность поля кода операции; 
- $RСА$ — разрядность поля способа адресации.
<div style="page-break-after: always;"></div>

# 24. Способы адресации. Непосредственная, прямая и косвенная адресации

> [!tldr] TL:DR
> - В АСК разные способы адресации операндов в ВМ: **исполнительный адрес операнда** (А ИСП) и **адресный код команды** (А К).
> - **Способ адресации** - метод формирования исполнительного адреса по адресному коду команды.
> - Выбор способов **адресации влияет на** удобство программирования и эффективность, измеряемую затратами оборудования (C) и затратами времени (T).
> 
**Непосредственная адресация:**
> - Операнд указывается **непосредственно в команде в виде константы**.
> - В адресном поле могут быть только константы, размер ограничен длиной адресного поля
> - Эффективен в плане затрат на оборудование и времени выполнения.
> 
**Прямая адресация:**
> - Адресный код напрямую указывает **номер ячейки памяти**.
> - Ограниченный размер адресного пространства, адрес не изменяется в процессе вычислений.
> 
**Косвенная адресация:**
> - Адрес операнда **указывается в регистре**, операнд находится в **ячейке с адресом**, хранящимся в регистре.
> - Используется двукратное обращение к памяти, задействуется лишняя ячейка памяти для хранения адреса операнда.

В адресно-связанных компьютерах (АСК) любой виртуальной машине (ВМ) предусмотрены различные способы адресации операндов. 

- **Исполнительный адрес операнда** (А ИСП) представляет собой двоичный код номера ячейки памяти, которая служит источником или приемником операнда. 
- **Адресный код команды** (А К) - это двоичный код в адресном поле команды, из которого необходимо сформировать исполнительный адрес операнда. 

В современных виртуальных машинах исполнительный адрес и адресный код не совпадают, и для доступа к данным требуется соответствующее преобразование. **Способ адресации - это метод формирования исполнительного адреса операнда по адресному коду команды**. Различные виртуальные машины используют различные приемы для определения способа адресации в данной команде:

1. Разным способам адресации соответствуют разные коды операции.
2. Добавление в состав команды специального поля способа адресации, содержимое которого определяет, какой из способов адресации должен быть применен.
3. В команде может быть несколько полей способов адресации - по одному на каждый адрес.
4. В команде вообще отсутствует адресная информация, то есть имеет место неявная адресация.

При выборе способов адресации существенное **значение имеет** не только удобство программирования, но и эффективность способа, которая характеризуется двумя показателями: **затратами оборудования** (C) и **затратами времени** (T) на доступ к адресуемым данным.

## Непосредственная адресация
Значение операнда **непосредственно указывается в самой команде**, а не через ссылку на ячейку памяти или регистр. Это значение обычно представлено в виде константы.

   ```x86
   ; Поместить значение 42 в регистр EAX
   MOV EAX, 42
   ```

Несколько сколько особенностей данного метода:

- В адресном поле могут быть указаны **только константы**.
- Размер непосредственного операнда **ограничен длиной адресного поля** команды.
- Время **выполнения** команды **сокращается**.
- **Экономится память**.

*В плане эффективности этот способ идеален*, так как затраты на оборудование (C) равны нулю, и время доступа (T) также равно нулю.
## Прямая адресация
В случае прямой адресации, адресный **код напрямую указывает номер ячейки памяти**, к которой производится обращение, что означает совпадение адресного кода с исполнительным адресом. 

![[Pasted image 20231214225129.png]]

   ```x86
   ; Поместить значение, хранящееся по адресу 0x1000, в регистр EAX
   MOV EAX, [0x1000]
   ```

Некоторые особенности этого метода включают:
- Ограниченный размер адресного пространства.
- Адрес, указанный в команде, не может быть изменен в процессе вычислений.
## Косвенная адресация
Адрес операнда указывается в регистре, а сам операнд находится в ячейке памяти с адресом, **хранящимся в этом регистре**.

   ```assembly
   ; Загрузить адрес 0x1000 в регистр EBX
   MOV EBX, 0x1000
   ; Поместить значение, хранящееся по адресу в EBX, в регистр EAX
   MOV EAX, [EBX]
   ```

В случае косвенной адресации с использованием ограниченного адресного поля команды, указывается адрес ячейки памяти, содержащей полноразрядный адрес операнда. Содержимое адресного поля команды остается неизменным, в то время как косвенный **адрес** в процессе выполнения программы **можно изменять**. Этот подход часто используется для обработки массивов, списков или передачи параметров подпрограммам.

![[Pasted image 20231214225217.png]]

Некоторые особенности этого метода включают:
- Необходимость **в двухкратном обращении** к памяти.
- Задействуется **лишняя ячейка памяти** для хранения исполнительного адреса операнда.

Существует также многоуровневая или каскадная косвенная адресация, где адрес исполнительного операнда получается через **несколько уровней косвенности**, например: $А_{ИСП} = (... (А_{К}) ...)$
<div style="page-break-after: always;"></div>

# 25. Способы адресации. Базовая, индексная и относительная адресации

> [!tldr] TL:DR
> - **Адресное поле команды**, указывающее на регистр процессора, обычно имеет короткое размер, позволяя выбрать один из восьми или шестнадцати регистров общего назначения.
> - **Базовая регистровая адресация** вычисляет адрес операнда путем сложения базового адреса и смещения; базовый адрес обычно хранится в регистре.
> - Базовую регистровую адресацию **часто применяют для доступа к элементам массива**, где базовый регистр хранит начальный адрес массива, а поле адреса смещение относительно начального адреса.
> - **Индексная адресация** использует адрес ячейки памяти в поле адреса и регистр в качестве смещения относительно этого адреса.
> - **Автоинкрементная и автодекрементная адресация** автоматически изменяют содержимое индексного регистра до или после обращения к нему.
> - **Индексная адресация с масштабированием** и смещением умножает содержимое индексного регистра на масштабный коэффициент и суммирует с адресом в команде.
> - **Относительная адресация** получает исполнительный адрес операнда сложением содержимого поля адреса команды с содержимым счетчика команд.
> - **Программа перемещаема в памяти** при относительной адресации, обеспечивая неизменное взаимное положение команды и операнда в адресном пространстве.

В случае, когда **адресное поле команды указывает на регистр процессора**, обычно размер адресного поля составляет три или четыре бита, что позволяет выбрать один из восьми или шестнадцати регистров общего назначения (РОН). Некоторые особенности этого способа адресации включают:

![[Pasted image 20231214230119.png]]

- **Короткое адресное поле** в команде.
- Исключение обращений к памяти.
- Возможности ограничены малым числом регистров общего назначения.

## Базовая регистровая адресация
Адрес операнда вычисляется **путем сложения** базового адреса (base address) и смещения (offset). Базовый адрес обычно хранится в регистре.

   ```x86
   ; Загрузить значение, хранящееся по адресу (EBX + 0x1000)
   MOV EAX, [EBX + 0x1000] 
   ```

Базовую регистровую адресацию обычно используют для доступа к элементам массива, положение которого в памяти в процессе вычислений может меняться.

В базовый регистр заносится **начальный адрес массива**, а адрес элемента массива указывается в поле АС команды **в виде смещения** относительно начального адреса массива.


![[Pasted image 20231214230309.png]]

Особенность:
- Смещение имеет меньшую длину, чем полный адрес, и это позволяет сократить длину адресного поля команды.
## Индексная
Поле АС содержит адрес ячейки памяти, а регистр (указанный явно или неявно) — **смещение относительно этого адреса**.

   ```assembly
   ; Загрузить значение, хранящееся по адресу (0x1000 + EDX)
   MOV EAX, [0x1000 + EDX]
   ```

![[Pasted image 20231214230552.png]]

В некоторых ВМ увеличение или уменьшение содержимого индексного регистра до или после обращения к нему осуществляется автоматически как часть машинного цикла – автоиндексирование (может производиться неявно и автоматически).

**Автоинкрементная адресация** - автоиндексирование с увеличением содержимого индексного регистра.

**Автодекрементная адресация** - автоиндексирование с уменьшением содержимого индексного регистра.

**Индексная адресация с масштабированием и смещением:** с*одержимое индексного регистра умножается* на масштабный коэффициент и суммируется с АС (масштабный коэффициент может принимать значения 1, 2, 4 или 8, для чего в адресной части команды выделяется дополнительное поле).
## Относительная
Исполнительный адрес операнда получается путем сложения содержимого поля АК команды с содержимым счетчика команд. Адресный код в команде представляет собой смещение относительно адреса текущей команды.

   ```assembly
   ; Короткий переход на метку short_label
   JMP short_label 
   ```


![[Pasted image 20231214230616.png]]

Особенность:
- **программу перемещаема в памяти**: независимо от текущего расположения программы в адресном пространстве взаимное положение команды и операнда остается неизменным.
<div style="page-break-after: always;"></div>

# 26. Способы адресации. Адресации с автоувеличением, автоуменьшением, страничная адресация

> [!tldr] TL:DR
> - **Адресация с автоувеличением** использует регистр, содержащий адрес операнда, который **после выборки увеличивается на размер операнда**.
> - **Адресация с автоуменьшением** **уменьшает содержимое регистра на размер операнда** перед выполнением операции, что позволяет эффективно обрабатывать массивы данных и стек.
> - **Страничная адресация** разбивает **адресное пространство на страницы**, с базовым адресом страницы в регистре адреса страницы (РАС) и указанием смещения внутри страницы в адресной части команды.
## Адресация с автоувеличением
При этой адресации используемый регистр **содержит адрес операнда**. После выборки операнда **производится увеличение содержимого регистра на s** (размер операнда в байтах). Формат операнда определяется кодом операции. Данная адресация подобна адресации с автоуменьшением, но обработка элементов массива производится в направлении увеличении адресов.

![[Pasted image 20231220221634.png]]

## Адресация с автоуменьшением
При использовании данного способа адресации п**еред выполнением операции содержимое используемого регистра уменьшается на s** (размер операнда в байтах), определяемый форматом данных операнда (по коду операции), после чего регистр содержит адрес операнда. Способ адресации с автоуменьшением особенно эффективен при работе с массивами данных одного формата, так как позволяет без дополнительных команд получать в регистре адрес следующего элемента массива, а также при обработке таблиц и организации стека. При этом массив «просматривается» от старшего элемента к младшему.

![[Pasted image 20231220221706.png]]
## Страничная адресация
**Предполагается разбиение адресного пространства на страницы**. Страница определяется своим начальным адресом, выступающим в качестве базы. **Старшая часть** этого адреса хранится в специальном регистре — регистре адреса страницы (РАС). В адресном коде команды указывается **смещение внутри страницы**, рассматриваемое как младшая часть исполнительного адреса. Исполнительный адрес образуется конкатенацией (присоединением) АС к содержимому РАС.

![[Pasted image 20231214230752.png]]

Для **ВМ с аккумуляторной АСК** главные способы адресации — это прямая и непосредственная. Для RISC-архитектуры преимущественный способ адресации — регистровая адресация. В регистровых ВМ используются различные сочетания способов адресации.
<div style="page-break-after: always;"></div>

# 27. Цикл выполнения команды в процессоре

> [!tldr] TL:DR
> - **Цикл команды** включает этапы: выборка (извлечение) команды, декодирование, вычисление исполнительных адресов, выборка операндов, исполнение операции, запись результата и формирование адреса следующей команды.
> - **На этапе выборки команды** команда извлекается из памяти и размещается в регистре команды (РК).
> - **Декодирование команды** включает расшифровку содержимого для определения операции и адресов операндов, а также подготовку электронных схем ВМ к выполнению действий.
> - **Вычисление исполнительных адресов** определяет адреса операндов и другие параметры для выполнения команды.
> - **Выборка операндов** включает обращение к памяти для получения значений операндов.
> - **Исполнение операции** осуществляется с использованием выбранных операндов.
> - **Запись результата** в память или регистры процессора является частью этапа исполнения.
> - **Формирование адреса следующей команды** осуществляется путем увеличения содержимого счетчика команд на длину текущей команды.

Цикл команды - действия, требуемые для выборки и выполнения команды. В общем случае цикл команды включает в себя несколько этапов:

1. **Выборка команды (ВК):** Этап, на котором *команда извлекается из памяти* и размещается в регистре команды (РК, IR).

2. **Декодирование команды (ДК):** *Расшифровка содержимого* команды для определения выполняемой операции и адресов операндов.

3. **Вычисление исполнительных адресов (ВА):** На этом этапе *определяются адреса операндов* и другие параметры, необходимые для выполнения команды.

4. **Выборка операндов (ВО):** Осуществляется *обращение к памяти* для получения значений операндов.

5. **Исполнение операции (ИО):** *Выполнение операции*, указанной в команде, с использованием выбранных операндов.

6. **Запись результата (ЗР):** Результат операции *записывается обратно в память* или в регистры, в зависимости от характера команды.

7. **Формирование адреса следующей команды (ФАСК):** *Настройка счетчика команд* для получения адреса следующей выполняемой команды.

Этапы ВК – ДК – ВА – ВО – ИО – ЗР – ФАСК образуют **стандартный цикл команды**.

## Определение
### Этап выборки команды
Центральный процессор извлекает команду из памяти, используя адрес из счетчика команд (СК). Двоичный код команды помещается в регистр команды (РК), и с этого момента он становится "видимым" для процессора. Без учета промежуточных пересылок и сигналов управления это можно описать следующим образом: $РК := ОП[(СК)]$

Этап выборки команды можно считать завершенным лишь после того, как в РК будет помещен полный код команды. Информация о фактической длине команды содержится в полях кода операции (КОП) и адреса (СА).

Пример: для 16-разрядной команды выборку можно описать следующим образом:

1. **Получение старшей части РК (ПСтРК):** $РК(15–8) := ОП[(СК)]$
2. **Увеличение счетчика команд (+1СК):** $СК := СК + 1$
3. **Получение младшей части РК (ПМлРК):** $РК(7–0) := ОП[(СК)]$
### Этап декодирования команды
После выборки команды она должна быть декодирована. В результате декодирования определяется:
- Находится ли в РК полный код команды, или требуется дозагрузка остальных слов команды.
- Какие последующие действия необходимы для выполнения данной команды.
- Если команда использует операнды, то откуда они должны быть взяты (номер регистра или адрес ячейки основной памяти).
- Если команда формирует результат, то куда этот результат должен быть направлен.

Ответы на эти вопросы предоставляются следующими процессами:

- Расшифровка кода операции, результатом которой может быть унитарный код: $$\text{УнитК} := \text{DECOD}(\text{КОП})$$
- Анализ адресной части команды, включая поле способа адресации.

По результатам декодирования производится подготовка электронных схем ВМ к выполнению соответствующих действий.
### Этап вычисления исполнительных адресов
Для физического доступа к основной памяти необходимо подать на ее адресные входы исполнительный адрес ячейки. В адресной части команды обычно указывается только адресный код, который предварительно должен быть преобразован в соответствующий исполнительный адрес. При преобразовании руководствуются способом адресации, указанным в команде.
### Этап выборки операндов
Применяется для команд обработки операндов. Вычисленные на предыдущем этапе исполнительные адреса используются для считывания операндов из памяти и занесения их в определенные регистры процессора.
### Этап исполнения операции
Реализуется указанная в команде операция. Содержание этого этапа также сугубо индивидуально.
### Этап записи результата
Присутствует в цикле тех команд, которые предполагают занесение результата в регистр или ячейку основной памяти. Фактически его можно считать частью этапа исполнения.
### Этап формирования адреса следующей команды
Для вычисления адреса следующей выполняемой команды достаточно увеличить содержимое СК на длину текущей команды. Для однословной команды это описывается микрооперацией: $+1СК:СК:=СК+1$. Длина команды, а также ее способность изменить естественный порядок выполнения команд, выясняются на этапе декодирования. Если извлеченная команда условного или безусловного перехода, вызова процедуры и т. п., процесс формирования адреса следующей команды сводится к занесению в СК адресной части кода команды.
<div style="page-break-after: always;"></div>

# 28. Процессор. Одношинная архитектура

> [!tldr] TL:DR
> - **Процессор** - электронный блок или интегральная схема, осуществляющая обработку данных и управление программным процессом.
> - **Счетчик команд** (СК, PC) неотъемлемый элемент устройства управления, реализуется как регистр и обеспечивает управление выполнением программы.
> - Согласно фон-неймановскому принципу, **адрес следующей команды** получается увеличением адреса ячейки текущей команды на длину команды.
> - **Регистр команды (РК, IR)** хранит команду в течение ее выполнения, разделяется на **регистр кода операции (РКОп) и регистр адреса (РА)**.
> - **Регистр адреса (MAR)** используется для обращения к памяти, а регистр данных (MDR) хранит данные, предназначенные для записи в память или чтения из нее.
> - **Устройства связаны с одной шиной,** что может ограничивать производительность системы из-за последовательного характера обмена информацией между процессором и устройствами.

**Процессор** - электронный блок либо интегральная схема, непосредственно осуществляющая процесс обработки данных и программное управление этим процессом. Процессор *дешифрует и выполняет* команды программ, организует обращение к ОП, инициирует работу ПУ, воспринимает и обрабатывает внешние события. Процессор осуществляет управление взаимодействием всех устройств ЭВМ (при наличии специальных процессоров эти функции разделяются).

![[Pasted image 20231214231105.png]]

**Счетчик команд (СК, PC)** — неотъемлемый элемент устройства управления любой ВМ. В ряде ВМ счетчик команд реализуется в виде обычного регистра.

В соответствии с фон-неймановским принципом программного управления **адрес** очередной **команды** может быть получен **путем увеличения адреса ячейки**, из которой была считана текущая команда, на длину выполняемой команды. Реализацию этого обеспечивает СК — в нем хранится и модифицируется адрес очередной команды программы.

Команда извлекается из памяти и размещается в регистре команды (РК, IR). Этот этап - **выборка команды**. В РК команда хранится в течение всего времени ее выполнения. РК иногда рассматривают как совокупность двух регистров — **регистра кода операции (РКОп) и регистра адреса (РА)**, в которых хранятся соответствующие составляющие команды.

**Регистр адреса** (MAR) – в нем адрес, по которому производится обращение к памяти.

**Регистр данных** (MDR) - в нем данные, которые должны быть записаны в память или прочитаны из нее по этому адресу.

![[Pasted image 20231214231600.png]]

**Все устройства связаны с одной шиной.** Поскольку шина может использоваться только для одной передачи, то в данный момент времени только одно устройство может быть активным. 

Чтение кодов команд из памяти системы также производится с помощью циклов чтения. Поэтому в случае одношинной архитектуры на системной магистрали **чередуются циклы чтения команд и циклы пересылки** ( чтения и записи) данных, но протоколы обмена остаются неизменными независимо от того, что передается - данные или команды. В случае двух-шинной архитектуры циклы чтения команд и записи или чтения данных разделяются по разным шинам и могут выполняться одновременно.

Недостатки однопроцессорной одношинной структуры в том, что при использовании одной шины общая продуктивность системы, во-первых, диктуется производительностью процессора, во-вторых, **ограничивается последовательным характером процесса** обмена информацией процессора с прочими устройствами.
<div style="page-break-after: always;"></div>

# 29. Многошинная архитектура процессора

> [!tldr] TL:DR
> - **В многошинной архитектуре** обмен по шинам может быть независимым и параллельным во времени, что позволяет оптимизировать структуры шин для каждой задачи.
> - Многошинная архитектура **ускоряет работу** микропроцессорной системы при оптимальном выборе параметров шин, хотя т**ребует дополнительных затрат** на аппаратуру и усложняет структуру процессора.
> - Преимущества многошинной архитектуры **проявляются лучше внутри одной микросхемы**, особенно в микроконтроллерах, где требуется максимальное быстродействие при заданной тактовой частоте.

В случае многошинной архитектуры **обмен по шинам может быть независимым, параллельным во времени**. Соответственно, структуры шин (количество разрядов кода адреса и кода данных, порядок и скорость обмена информацией и т.д.) могут быть выбраны оптимально для той задачи, которая решается каждой шиной. Поэтому при прочих равных условиях переход на многошинную архитектуру ускоряет работу микропроцессорной системы, хотя и требует дополнительных затрат на аппаратуру, усложнения структуры процессора. Память данных в этом случае имеет свое распределение адресов, а память команд — свое.

![[Pasted image 20231214231617.png]]

Проще всего преимущества многошинной архитектуры **реализуются внутри одной микросхемы**. В этом случае можно также существенно уменьшить влияние недостатков этой архитектуры. Поэтому основное ее применение — **в микроконтроллерах**, от которых не требуется решения слишком сложных задач, но зато необходимо максимальное быстродействие при заданной тактовой частоте.

Примеры многоядерных архитектур включают в себя процессоры от Intel (например, Intel Core i7, i9) и AMD (например, AMD Ryzen). Многоядерные процессоры стали стандартом в современных компьютерах и серверах, поскольку они предоставляют эффективное решение для обработки сложных вычислительных задач и многозадачных сценариев.
<div style="page-break-after: always;"></div>

# 30. Принцип микропрограммного управления

> [!tldr] TL:DR
> - **Устройство управления (УУ)** ВМ выполняет функции управления вычислительным процессом, обеспечивая автоматическое выполнение команд программы через последовательность машинных циклов.
> - **Микрооперации** - элементарные действия в пределах одного такта сигналов синхронизации, объединяются в микрокоманду (МК).
> - **Микропрограмма** - последовательность микрокоманд, определяющая содержание и порядок выполнения цикла команды.
> - **Сигналы управления**, генерируемые микропрограммным автоматом (МПА), вызывают выполнение одновременных микроопераций.
> - Управляющая часть **УУ включает** регистр команды (РК), микропрограммный автомат (МПА) и узел прерывания программ (УПП).
> - **Адресная часть УУ включает** операционный узел устройства управления (ОПУУ), счетчик команд (СК) и регистр адреса памяти (РАП).
> - **Принцип микропрограммного управления** предполагает использование микропрограммы для управления выполнением инструкций в процессоре, разбивая инструкции на микроинструкции и управляя их выполнением.

**Устройство управления** (УУ) ВМ **выполняет функции управления вычислительным процессом**, обеспечивая автоматическое выполнение команд программы. Выполнение программы в ВМ представляет собой последовательность машинных циклов для каждой команды. Каждый этап машинного цикла реализуется чередой элементарных действий в узлах. 

- **Элементарные действия**, осуществляемые в пределах одного такта сигналов синхронизации, **называются микрооперациями (МО)**.
- **Микрооперации,** которые выполняются **одновременно**, объединяются в **микрокоманду** (МК). 
- **Последовательность микрокоманд**, определяющая содержание и порядок выполнения цикла команды, **образует микропрограмму**.

**Сигналы управления**, вызывающие выполнение одновременных микроопераций, генерируются центральным узлом устройства управления — **микропрограммным автоматом (МПА)**.

![[Pasted image 20231214232106.png]]

В состав **управляющей части УУ** входят следующие компоненты:
- Регистр команды (РК), который состоит из адресной и операционной частей.
- Микропрограммный автомат (МПА).
- Узел прерывания программ (УПП).

**Адресная часть УУ** включает в себя следующие элементы:
- Операционный узел устройства управления (ОПУУ).
- Счетчик команд (СК).
- Регистр адреса памяти (РАП).

**Принцип микропрограммного** управления предполагает **использование микропрограммы для управления выполнением** инструкций в процессоре. Микропрограммное управление является одним из подходов к организации управления процессором и исполнению инструкций. В этом подходе инструкции выполняются последовательно, и каждая инструкция может быть разбита на более мелкие шаги, называемые микроинструкциями. Микропрограммное управление используется для управления выполнением этих микроинструкций.
<div style="page-break-after: always;"></div>

# 31. Структура устройства управления. Микропрограммный автомат (МПА) 
Функционирование вычислительной машины обеспечивают системы управления (СУ), формируемые устройством управления (УУ), в данном случае, конкретно - микропрограммным автоматом (МПА).

УУ для выполнения своих функций должно обладать входами, которые позволяют определить состояние управляемой системы, и выходами, через которые осуществляется управление поведением системы.

![[Pasted image 20231214232216.png]]
<div style="page-break-after: always;"></div>

# 32. МПА с жесткой логикой

> [!tldr] TL:DR
> - Выходные сигналы управления в **микропрограммном автомате (МПА)** формируются с использованием заранее соединенных логических схем.
> - Фрагмент схемы управления **предполагает порядок выработки** управляющего сигнала Сk в i-м и S-м тактах выполнения команды, зависящий от значений осведомительных сигналов х1 и х3.
> - Особенности данной схемы включают э**кономичность и высокое быстродействие** узлов МПА при реализации простой системы команд.
> - С увеличением сложности системы команд схемы МПА становятся более сложными, что снижает их быстродействие.
> - **Малая регулярность схемы** МПА и сложности при размещении на кристалле интегральной микросхемы становятся проблемой.

При разработке такого микропрограммного автомата (МПА), выходные сигналы управления формируются с использованием заранее соединенных между собой логических схем.

![[Pasted image 20231214232252.png]]

Приведенный фрагмент схемы управления сигналом предполагает следующий порядок выработки управляющего сигнала Сk в i-м и S-м тактах выполнения команды. Сигнал Сk появляется в i-м такте только при значениях осведомительных сигналов х1 = 1 и х3 = 1, а в S-м такте появляется всегда.

![[Pasted image 20231220222009.png]]

Особенности данной схемы включают в себя:
- При реализации простой системы команд узлы микропрограммного автомата (МПА) с жесткой логикой являются экономичными и обеспечивают высокое быстродействие.
- С увеличением сложности системы команд схемы МПА становятся более сложными, что влечет за собой уменьшение их быстродействия.
- Малая регулярность схемы МПА и, следовательно, большие трудности при размещении устройства управления такого типа на кристалле интегральной микросхемы.
<div style="page-break-after: always;"></div>

# 33. МПА с программируемой логикой

> [!tldr] TL:DR
> - **Для инициирования микрооперации** в микропрограммном автомате (МПА) достаточно установить соответствующий сигнал управления на соответствующей линии.
> - **Сигналы управления представлены** управляющими словами, называемыми микрокомандами (МК), в МПА с программируемой логикой.
> - **Микрокоманда** соответствует одному такту работы вычислительной машины и активирует необходимые сигналы управления в данном такте.
> - Последовательность микрокоманд, описывающая выполнение этапа цикла команды, формирует **микропрограмму (МП)**.
> - Микропрограммы, разрабатываемые для каждого этапа машинного цикла, **хранятся в управляющей памяти (УПМ) или памяти микропрограмм**.
> - **Процесс формирования сигналов управления** включает извлечение из УПМ микрокоманды, интерпретацию ее содержимого как набора сигналов для выполнения конкретной микрооперации.

Для инициирования любой микрооперации достаточно сформировать соответствующий сигнал управления на соответствующей линии управления, переведя такую линию в активное состояние с использованием двоичных цифр 1 (активное состояние) и 0 (пассивное состояние).

Сигналы управления в микропрограммном автомате (МПА) с программируемой логикой представлены управляющими словами, называемыми микрокомандами (МК). Каждая микрокоманда соответствует одному такту работы вычислительной машины и определяет, какие сигналы управления должны быть активированы в данном такте.

Последовательность микрокоманд, описывающая выполнение определенного этапа цикла команды, формирует микропрограмму (МП) - набор инструкций firmware, который программно управляет выполнением команд.

Микропрограммы разрабатываются для каждого этапа машинного цикла каждой команды виртуальной машины и сохраняются в специальном устройстве памяти, известном как управляющая память (УПМ) или память микропрограмм.

Процесс формирования сигналов управления происходит последовательно с каждым тактовым импульсом. Он включает в себя извлечение из УПМ очередной микрокоманды (МК) микропрограммы. Информация, содержащаяся в каждой микрокоманде, интерпретируется как набор сигналов управления, необходимых для выполнения конкретной микрооперации на данном этапе цикла команды.

![[Pasted image 20231214232404.png]]

<div style="page-break-after: always;"></div>

# 34. Запоминающие устройства (ЗУ). Характеристики ЗУ

> [!tldr] TL:DR
> - Запоминающие устройства (ЗУ) **предназначены для хранения и обеспечения доступа к данным** в компьютерных системах.
> - **Емкость** определяет количество байт, а единица пересылки зависит от ширины шины данных.
> - **Метод доступа** включает последовательный, произвольный, прямой и ассоциативный доступ.
> - **Устойчивость к перезаписи** определяет легкость изменения данных.
> - **Энергопотребление** важно для энергоэффективности, особенно в портативных устройствах.
> - **Быстродействие** включает время доступа, длительность цикла памяти и скорость передачи данных.
> - **Стоимость** определяется отношением общей стоимости к емкости в битах.
> - **Физические типы** ЗУ включают полупроводниковую память, магнитные диски и оптические диски.
> - **Энергозависимость** различается: магнитная и оптическая память энергонезависимы, полупроводниковая может быть как энергозависимой, так и нет.
> - Важно учитывать, приводит ли **считывание** информации **к ее разрушению**.

Запоминающие устройства (ЗУ) предназначены для хранения и обеспечения доступа к данным в компьютерных системах. Характеристики запоминающих устройств включают различные параметры и свойства, определяющие их производительность, емкость, скорость доступа и другие аспекты. 

 **Основные функции ЗУ:
- Прием (запись).
- Хранение.
- Выдача данных (чтение или считывание).
## Характеристика ЗУ
- **Емкость** (сколько байт); 
- **Единица пересылки** (Для основной памяти (ОП) единица пересылки определяется шириной шины данных, то есть коли­чеством битов, передаваемых по линиям шины параллельно.); 
- Метод доступа:
	- **Последовательный доступ:** ЗУ с последовательным доступом ориентировано на хранение информации в виде последовательности блоков данных, называе­мых записями.
	- **Произвольный доступ:** Каждая ячейка памяти имеет уникальный физический адрес.
	- **Прямой доступ:** Каждая запись имеет уникальный адрес, отражающий ее фи­зическое размещение на носителе информации.
	- **Ассоциативный доступ:** Этот вид доступа позволяет выполнять поиск ячеек, содержащих такую информацию, в которой значение отдельных битов совпадает с состоянием одноименных битов в заданном образце.
- **Устойчивость к перезаписи:** Определяет, насколько легко можно записывать новые данные или изменять существующие в хранящихся данных.
- **Энергопотребление:** Определяет количество энергии, которое устройство потребляет при работе. Энергосберегающие технологии могут быть важными в портативных устройствах или в ситуациях, где важна энергоэффективность.
- **Быстродействие**:
	- Время доступа, соответствует интервалу времени от момента поступления адреса до момента, когда данные заносятся в память или становятся доступными.  
	- Длительность цикла памяти или период обращения, минимальное время между двумя последовательными обращениями к памяти.
	- Скорость передачи. Это скорость, с которой данные могут передаваться в память или из нее.
- **Стоимость:** Стоимость ЗУ принято оценивать отношением общей стоимости ЗУ к его ем­кости в битах, то есть стоимостью хранения одного бита информации.
### Физический тип
Говоря о физическом типе запоминающего устройства, необходимо упомянуть три наиболее распространенных технологии ЗУ — это полупроводниковая память, память с магнитным носителем информации, используемая в магнитных дисках и лентах, и память с оптическим носителем — оптические диски.
- Энергозависимость, в энергозависимой памяти информация может быть искажена или потеряна при отключении источника пи­тания. В энергонезависимых ЗУ записанная информация сохраняется и при от­ключении питающего напряжения. Магнитная и оптическая память — энергоне­зависимы. Полупроводниковая память может быть, как энергозависимой, так и нет, в зависимости от ее типа. 
- Нужно учитывать, приводит ли считывание информации к ее разрушению.
<div style="page-break-after: always;"></div>

# 35. Запоминающие устройства (ЗУ). Классификация ЗУ

> [!tldr] TL:DR
> - Основная память **включает** **оперативные** (ОЗУ, RAM) и **постоянные** (ПЗУ, ROM) запоминающие устройства.
> - **Стековая память** организована по принципу "последним записан - первым считан", используется эффективно в компилирующих и интерпретирующих программах, а также при вычислении арифметических выражений в польской инверсной записи.
> - **Ассоциативная память** (АЗУ) способна сравнивать информацию с заданным образцом и указывать на соответствие или несоответствие.
> - **Уровни иерархии взаимосвязаны**, данные на одном уровне могут быть найдены на более низком уровне, соотношение стоимость/бит уменьшается, емкость возрастает, время выборки растет, частота обращения к памяти уменьшается по мере движения вниз по структуре.


Основная память — может включать в себя два типа устройств:
- Оперативные запоминающие устройства (ОЗУ, RAM).
- Постоянные запоминающие устройства (ПЗУ, ROM).

**Стековая память** — cтековой называют память, доступ к которой организован по принципу: "последним записан - первым считан". Использование принципа доступа к памяти на основе механизма LIFO началось с больших ЭВМ. Применение стековой памяти оказалось очень эффективным при построении компилирующих и интерпретирующих программ, при вычислении арифметических выражений с использованием польской инверсной записи.

**Ассоциативная память** — АЗУ — это устройство, способное хранить информацию, сравнивать ее с некоторым заданным образцом и указывать на их соответствие или несоответствие друг другу. Ассоциативный признак - признак, по которому производится поиск информации. Признак поиска - кодовая комбинация, выступающая в роли образца для поиска.

**Уровни иерархии взаимосвязаны** - все данные на одном уровне могут быть также найдены на более низком уровне, и все данные на этом более низком уровне могут быть найдены на следующем нижележащем уровне и т. д.  По мере движения вниз по иерархической структуре: 
1) уменьшается соотношение «стоимость/бит», 
2) возрастает емкость, 
3) растет время выборки, 
4) уменьшается частота обращения к памяти со стороны центрального процессора.

![[Pasted image 20231220222134.png]]

<div style="page-break-after: always;"></div>

# 36. Запоминающие устройства (ЗУ). Основная память

> [!tldr] TL:DR
> - Основная память может включать ОЗУ (RAM) и ПЗУ (ROM).
> - **Необходимость объединения микросхем** памяти возникает из-за различия разрядности ячеек и шины данных.
> - **Увеличение разрядности ЗУ** происходит за счет объединения адресных входов, формируя модуль памяти, который может быть одной микросхемой или несколькими, образуя банк памяти.
> - **Блочная схема** распределения адресов разбивает адресное пространство на группы, каждая обслуживаемая отдельным банком, с выбором банка по старшим разрядам адреса.
> - **Циклическая схема** чередует адреса между банками, используя младшие разряды адреса для выбора банка и старшие для выбора ячейки внутри банка.

Основная память может включать в себя два типа устройств: 
- оперативные запоминающие устройства (ОЗУ, RAM), 
- постоянные запоминающие устройства (ПЗУ, ROM). 

Необходимость **объединения нескольких микросхем памяти** возникает по причине того, что разрядность ячеек в микросхемах памяти, как правило, меньше разрядности шины данных МПС;

Увеличение разрядности ЗУ реализуется за счет **объединения адресных входов**, объединяемых микросхем памяти. 

Полученную совокупность микросхем называют модулем памяти. **Модулем можно считать и единственную микросхему**, если она уже имеет нужную разрядность. Один или несколько модулей образуют **банк памяти**.

При использовании блочной памяти, состоящей из B банков, адрес ячейки A преобразуется в пару (b, w), где b – номер банка, w – адрес ячейки внутри банка.

Известны **три схемы распределения адресов A** по банкам памяти (распределения разрядов адреса A между b и w):
- **блочная** – номер банка b определяют старшие разряды адреса A;
- **циклическая** – b = A mod B (остаток от деления), w = A div B (частное от деления);
- **блочно-циклическая** – комбинация первых двух схем.
### Блочная схема

![[Pasted image 20231220222207.png]]

Увеличение разрядности ЗУ реализуется за счет **объединения адресных входов** объединяемых ИМС(интегральная микросхема ) ЗУ - модуль памяти. Один или несколько модулей образуют **банк памяти**.

Адресное пространство памяти разбивается на группы последовательных адресов, и каждая такая группа обеспечивается отдельным банком памяти. Для обращения к ОП используется 9-разрядный адрес, семь младших разрядов которого (А6-А0) поступают параллельно на все банки памяти и выбирают в каждом из них одну ячейку. Два старших разряда адреса (A8, А7) содержат номер банка. Выбор банка обеспечивается либо с помощью дешифратора номера банка памяти, либо путем мультиплексирования информации. В функциональном отношении такая ОП может рассматриваться как единое ЗУ, емкость которого равна суммарной емкости составляющих банков, а быстродействие – быстродействию отдельного банка.
## Циклическая схема

![[Pasted image 20231220222228.png]]

Прием чередования адресов базируется на рассмотренном ранее свойстве локальности по обращению, согласно которому последовательный доступ в память обычно производится к ячейкам, имеющим смежные адреса. Суть процедуры чередования адресов состоит в том, что соседние адреса относятся к разным банкам. Чередование адресов обеспечивается за счет использования для распределения адресов между банками памяти циклической схемы. В нашем примере для выбора банка используются два младших разряда адреса, а для выбора ячейки в банке – 7 старших разрядов.
<div style="page-break-after: always;"></div>

# 37. Запоминающие устройства (ЗУ). Стековая память

> [!tldr] TL:DR
> - **Стековая память** - специальный тип запоминающего устройства, организованного по принципу стека с LIFO (Last In, First Out) порядком.
> - **Стековая архитектура** представляет собой безадресную память с последовательным доступом.
> - В стековом ЗУ ячейки формируют одномерный массив, где слова связаны разрядными цепями и доступны в определенном порядке.
> - Слова привязаны к своему относительному **положению относительно других слов**.
> - **Слова могут перемещаться, сохраняя упорядоченность**, и считываются в тот момент, когда оказываются в нужной ячейке.
> - Стековые ЗУ делятся на два типа: FIFO (First In, First Out) и LIFO (Last In, First Out).

**Стековая память** - это специальный тип запоминающего устройства, организованного по принципу стека, который представляет собой структуру данных, в которой элементы добавляются и удаляются с одного конца, называемого вершиной стека. В стековой архитектуре использование памяти происходит по принципу Last In, First Out (LIFO), что означает, что последний добавленный элемент будет первым удаленным. Стековая память является безадресной памятью с последовательным доступом.

В стековом ЗУ ячейки **образуют одномерный массив**, в котором соседние ячейки связаны друг с другом разрядными цепями передачи слов. Слова становятся доступными для чтения и записи только в определенном порядке. Каждое хранящееся слово привязано не к конкретной ячейке, а **к своему положению относительно других хранящихся слов**. Слова могут перемещаться по ячейкам, но при этом сохраняют свою взаимную упорядоченность. Поэтому достаточно обеспечить средства для чтения только определенной ячейки. Конкретное слово считывается в тот момент, когда в процессе перемещения по памяти оно оказывается в ячейке, из которой может производиться чтение. Аналогично достаточно обеспечить средства для записи только в определенную ячейку ЗУ.

В зависимости от того, как перемещаются слова в ЗМ, стековые ЗУ подразделяются на два основных типа:
- память типа очереди или память типа **FIFO** (First In First Out – первым вошел, первым вышел);
- стек или **LIFO** (Last In First Out – последним вошел, первым вышел).

![[Pasted image 20231220222320.png]]

<div style="page-break-after: always;"></div>

# 38. Запоминающие устройства (ЗУ). Ассоциативная память

> [!tldr] TL:DR
> - АЗУ способна **хранить и сравнивать информацию с заданным образцом**, используя ассоциативный признак и признак поиска в виде кодовой комбинации.
> - Ассоциативное запоминающее устройство **включает** массив для хранения N m-разрядных слов, регистр ассоциативного признака, схемы совпадения, регистр совпадений, регистр маски и комбинационную схему.
> - **Регистр ассоциативного признака** содержит код искомой информации, а его разрядность k меньше длины слова m.
> - Схемы совпадения параллельно сравнивают каждый бит всех хранимых слов с соответствующим битом признака поиска.
> - **Регистр совпадений** заполняется единицами, если все разряды соответствующей ячейки совпали с признаком поиска.
> - **Архитектура** ассоциативного ЗУ **определяется** видом поиска, техникой сравнения признаков, способом считывания и записи информации.

- **АЗУ** — это устройство, способное хранить информацию, сравнивать ее с некоторым заданным образцом и указывать на их соответствие или несоответствие друг другу.
- **Ассоциативный признак** - признак, по которому производится поиск информации. 
- **Признак поиска** - кодовая комбинация, выступающая в роли образца для поиска.

![[Pasted image 20231220222353.png]]

Ассоциативное запоминающее устройство включает в себя:
- запоминающий **массив для хранения N m-разрядных слов**, в каждом из которых несколько младших разрядов занимает служебная информация;
- **регистр ассоциативного признака**, куда помещается код искомой информации (признак поиска). Разрядность регистра k обычно меньше длины слова m;
- **схемы совпадения**, используемые для параллельного сравнения каждого бита всех хранимых слов с соответствующим битом признака поиска и выработки сигналов совпадения;
- **регистр совпадений**, где каждой ячейке запоминающего массива соответствует один разряд, в который заносится единица, если все разряды соответствующей ячейки совпали с одноименными разрядами признака поиска;
- **регистр маски**, позволяющий запретить сравнение определенных битов;
- **комбинационную схему**, которая на основании анализа содержимого регистра совпадений формирует сигналы, характеризующие результаты поиска информации.

Общность идеи ассоциативного поиска информации отнюдь не исключает разнообразия архитектур ассоциативных ЗУ. Конкретная архитектура **определяется сочетанием четырех факторов**:
- вида поиска информации;
- техники сравнения признаков;
- способа считывания информации при множественных совпадениях;
- способа записи информации.
<div style="page-break-after: always;"></div>

# 39. Кэш-память. Структурная организация
Когда ЦП пытается прочитать слово из основной памяти, **сначала осуществляется поиск** копии этого слова **в кэше**. Если такая копия существует, **обращение к ОП не производится**, а в ЦП передается слово, извлеченное из кэш-памяти.

**Между** ОП и процессором размещается небольшая, но **быстродействующая буферная память**, куда в процессе работы копируются те участки ОП, к которым производится обращение со стороны процессора. 

Обычно в компьютере имеется **два уровня кэш-памяти**. 
- Первичный кэш располагается на микросхеме процессора и называется кэшем первого уровня (**L1**). 
- Вторичный кэш имеет больший объем, располагается между первичным кэшем и остальной памятью и называется кэшем второго уровня (**L2**). 

- **Попадание в кэш (hit)** – слово, запрашиваемое процессором, есть в кэше. 
- **Промах чтения (miss)** - слово, адресуемое операцией считывания, отсутствует в кэше.

![[Pasted image 20231220222606.png]]
<div style="page-break-after: always;"></div>

# 40. Способы отображения оперативной памяти на кэш-память

> [!tldr] TL:DR
> - **Отображение блока** основной памяти на кэш-память включает копирование блока в строку кэш-памяти, и все обращения к блоку в ОП переадресовываются на соответствующую строку кэш-памяти.
> - При прямом отображении **адрес** строки i кэш-памяти определяется **выражением** i = j mod m, где m - общее число строк в кэш-памяти, и каждый 128-й блок ОП отображается на строку с номером i.
> - **Полностью ассоциативное отображение** позволяет загружать любой блок ОП в любую строку кэш-памяти, выделяя в адресе ОП тег и поле слова.
> - **Множественно-ассоциативное отображение** разбивает кэш-память на v подмножеств, каждое из которых содержит k строк, являясь компромиссом между прямым и полностью ассоциативным отображением.

Сущность отображения блока основной памяти на кэш-память состоит в копировании этого блока в какую-то строку кэш-памяти, после чего все обращения к блоку в ОП должны переадресовываться на соответствующую строку кэш-памяти.

![[Pasted image 20231220222815.png]]

RAM делится на сегменты, размер каждого сегмента равен размеру кэша, а каждый сегмент в свою очередь делится на блоки, размер каждого блока равен размеру кэш-линии.

При прямом отображении адрес строки i кэш-памяти, на которую может быть отображен блок из ОП, **однозначно определяется выражением**: $i =j\mod\:m$, где $m$ — общее число строк в кэш-памяти.

Иными словами, **на строку кэша с номером i** отображается каждый 128-й блок ОП, если отсчет начинать с блока, номер которого равен i.

![[Pasted image 20231220222830.png]]

Полностью ассоциативное отображение позволяет преодолеть недостаток прямого, разрешая загрузку любого блока ОП в любую строку кэш-памяти. Логика управления кэш-памяти **выделяет в адресе ОП** два поля: **поле тега и поле слова**.

Кэш-память делится на непересекающиеся подмножества (блоки) строк. Каждая строка ОП может попадать только в одно подмножество кэша. Для поиска блоков используется прямое отображение, а для поиска внутри подмножества – полностью ассоциативный поиск.

![[Pasted image 20231220222853.png]]

**Множественно-ассоциативное отображение** относится к группе методов частично-ассоциативного отображения. Оно является одним из возможных компромиссов сочетающим достоинства прямого и ассоциативного способов отображения. Кэш-память (как тегов, так и данных) **разбивается на v подмножеств**, каждое из которых содержит k строк.
<div style="page-break-after: always;"></div>

# 41. Виртуальная память. Варианты ее организации

> [!tldr] TL:DR
> - **Виртуализация памяти** - механизм для использования программами большего объема памяти, чем физически доступно в оперативной памяти, реализуется на уровне операционной системы и включает различные методы организации.
> - Физическая память и виртуальная память **разбиваются на страницы**, где физический адрес определяется парой (Pp, i), а виртуальный адрес - (Pv, i).
> - **Для отображения виртуального** адресного пространства на физическую память каждой задачи используются таблицы страниц, где дескрипторы хранят информацию о каждой странице, а преобразователь адресов транслирует номер виртуальной страницы в номер физической страницы.
> - Виртуальная память программы **делится на сегменты с независимой** адресацией байтов, и к виртуальному адресу добавляются разряды для определения сегмента, что создает иерархию организации программ: программа-сегмент-страница-байт.
> - **Иерархия таблиц**, соответствующая этой иерархии программ, используется для перевода виртуальных адресов в физические.

**Виртуализация памяти** - способ аппаратной и программной реализации концепции иерархической памяти. Виртуальная память представляет собой механизм, который позволяет программам использовать больший объем памяти, чем физически доступно в оперативной памяти компьютера. Она реализуется на уровне операционной системы и включает в себя несколько методов организации.

![[Pasted image 20231220222935.png]]
## Варианты организации виртуальной памяти

![[Pasted image 20231220223009.png]]

В этом случае память **разбивается на физические страницы (кадры, фреймы)**. А программа разбивается на виртуальные страницы.

Физический адрес ячейки памяти определяется парой (Pp, i), а виртуальный (Pv, i). Pv – номер виртуальной страницы, Pp – номер физической страницы, а I – номер ячейки (индекс) внутри страницы. 
Для отображения виртуального адресного пространства на физическую память для каждой задачи необходимо иметь таблицы страниц для трансляции адресных пространств. Для описания каждой страницы диспетчер памяти операционной системы заводит соответствующий дескриптор. По номеру виртуальной страницы в таблице дескрипторов текущей задачи находится соответствующий элемент (дескриптор). Если бит присутствия равен единице, то данная страница находится в ОЗУ и в дескрипторе находится номер физической страницы, отведенной под данную виртуальную страницу.

Преобразователь адресов — это часть операционной системы, транслирующая номер виртуальной страницы в номер физической страницы, расположенной в основной памяти, а также аппаратура, обеспечивающая этот процесс и позволяющая ускорить его.

![[Pasted image 20231220223028.png]]

Виртуальная память каждой программы делится на части, называемые сегментами, с независимой адресацией байтов внутри каждой части. При этом к виртуальному адресу добавляются дополнительные разряды левее номера страницы. Эти разряды определят номер сегмента.

Возникает определенная иерархия в организации программ, состоящая из четырех ступеней: программа-сегмент-страница-байт. Этой иерархии программ соответствует иерархия таблиц, служащих для перевода виртуальных адресов в физические. Программная таблица для каждой программы, загруженной в систему, указывает начальный адрес соответствующей сегментной таблицы. Сегментная таблица перечисляет сегменты данной программы с указанием начального адреса страничной таблицы, относящейся к данному сегменту. Страничная таблица определяет расположение каждой из страниц сегмента в памяти.
<div style="page-break-after: always;"></div>

# 42. Конвейерная обработка. Основы конвейеризации

**Цель** — повышение производительности современных компьютеров за счет увеличения количества операций, выполняемых за одну секунду.

**Конвейерная обработка** — это метод организации процесса вычислений, при котором задача разбивается на несколько последовательных этапов, и каждый этап выполняется независимо от предыдущего. Процессор конвейера разделен на несколько блоков, и каждый из них выполняет свою специфическую функцию. Основные принципы конвейерной обработки включают в себя:

![[Pasted image 20231220223117.png]]

![[Pasted image 20231220223127.png]]

1. **Разделение задачи:**
   - Задача разбивается на несколько подзадач, которые могут быть выполнены последовательно.

2. **Последовательность этапов (ступеней):**
   - Задача разбивается на несколько последовательных этапов, называемых ступенями. Каждая ступень выполняет определенный тип операции.

3. **Одновременное выполнение:**
   - Несколько задач выполняются одновременно на различных ступенях конвейера. Каждая новая задача начинает выполнение на следующей доступной ступени, когда предыдущая завершает свое выполнение.

4. **Параллелизм:**
   - Конвейерная обработка предоставляет параллелизм на уровне выполнения инструкций. Разные задачи могут находиться на различных ступенях конвейера одновременно.

5. **Увеличение производительности:**
   - Основная цель конвейерной обработки - увеличение общей производительности путем уменьшения времени выполнения каждой задачи и повышения загрузки процессора.

>[!warning] Важно
>Конвейерная обработка команд не приводит к ускорению выполнения каждой отдельной команды. Скорость команд остается прежней, но на единицу времени приходится большее их количество. 
>
>При этом, как только на одной из ступеней конвейера возникает затор и работа не завершается за один такт, весь конвейер останавливается в ожидании завершения процесса. Если описанные ситуации возникают достаточно часто, производительность компьютера снижается. 
>
>Важнейшей задачей разработчиков процессоров является выявление конфликтов, которые могут привести к приостановке процессора, и поиск путей их устранения.

# 43. Конфликты в конвейере команд. Риск по данным

> [!tldr] TL:DR
> - Конфликты в конвейерной обработке команд, такие как конфликт по данным (Data Hazard), могут замедлить выполнение программы из-за ожидания доступа к данным.
> - Зависимость по данным включает в себя **конфликты по чтению и записи**, где вторая инструкция зависит от результатов выполнения первой.
> - Конфликт по чтению возникает, когда инструкция пытается считать данные, которые еще не были записаны предыдущей инструкцией.
> - Конфликт по записи происходит, когда инструкция пытается записать данные, которые еще не были использованы предыдущей инструкцией.
> - **Техники управления конфликтами** включают переупорядочение инструкций, продвижение данных, промежуточные регистры и инструкции с отсроченным выполнением.

**Причина** - одной из ступеней конвейера может **не хватить выделенного ей диапазона времени**: либо исходный, либо результирующий операнд команды не доступен в положенное время.

**Решение** - применяются как **программные** (оптимизирующий компилятор), так и **аппаратные** (ускоренное продвижение информации) методы.

![[Pasted image 20231220223156.png]]

В конвейерной обработке команд могут возникать различные конфликты, которые могут замедлить выполнение программы. Один из таких конфликтов — это конфликт по данным (Data Hazard). Риск по данным включает в себя три основных типа конфликтов: зависимость по данным, конфликт по чтению и конфликт по записи.

1. **Зависимость по данным (Data Dependency):**
   - Зависимость по данным возникает, когда инструкция зависит от результата выполнения предыдущей инструкции. Это может быть поделено на два основных типа:
      - **Зависимость по чтению (Read-after-Read, RaR):** Когда вторая инструкция зависит от данных, прочитанных первой.
      - **Зависимость по записи (Write-after-Write, WaW):** Когда вторая инструкция зависит от результата записи первой.

2. **Конфликт по чтению (Read Hazard):**
   - Этот вид конфликта возникает, когда инструкция пытается считать данные, которые еще не были записаны предыдущей инструкцией. Если данные еще не доступны, требуется ожидание.

3. **Конфликт по записи (Write Hazard):**
   - Этот конфликт возникает, когда инструкция пытается записать данные в регистр или память, которые еще не были использованы предыдущей инструкцией. Это также может привести к ожиданию.

Для управления конфликтами по данным используются различные техники:

- **Переупорядочение инструкций (Instruction Reordering):** Конвейер может пытаться **переупорядочить** инструкции так, чтобы уменьшить задержки, связанные с конфликтами по данным.

- **Продвижение данных (Data Forwarding):** Также известное как forwarding или алиасинг, это механизм, который передает результат выполнения одной инструкции непосредственно в следующую, минуя запись в память. Это может уменьшить задержки из-за зависимости по данным.

- **Промежуточные регистры (Register Renaming):** Используются дополнительные регистры для временного хранения данных, что позволяет избежать конфликтов записи и чтения.

- **Инструкции с отсроченным выполнением (Out-of-Order Execution):** В таких системах процессор может выполнять инструкции в порядке, отличном от порядка появления в программе, чтобы избежать конфликтов по данным.
<div style="page-break-after: always;"></div>

# 44. Конфликты в конвейере команд. Риск по управлению

> [!tldr] TL:DR
> - Риск по управлению (Control Hazard) в конвейерной обработке команд возникает из-за задержек, **таких как промах при выборке команды из кэша или выполнение команды перехода**.
> - Организация очереди команд и упреждающая выборка являются решением для управления рисками по управлению в конвейере.
> - Риски по управлению включают ожидание ветвления, ожидание прыжка и неопределенность ветвления.
> - Использование предсказателей ветвления, техник предсказания прыжков и оптимизация конвейерной архитектуры помогают справиться с рисками по управлению и обеспечить эффективное выполнение программ.

**Причина** – задержка поступления очередной команды, например, в результате промаха при выборке команды из кэша или выполнения команды перехода.

![[Pasted image 20231220223217.png]]

**Решение** – организация очереди команд и упреждающая выборка.

![[Pasted image 20231220223230.png]]

Эффективность технологии тем выше, чем больше команд может быть одновременно считано из памяти.

Риск по управлению (Control Hazard) в конвейерной обработке команд связан с возможностью принятия неправильного решения о переходе или изменении порядка выполнения инструкций. Этот вид риска включает в себя неопределенность в управлении выполнением программы и может привести к неэффективному использованию конвейера. Рассмотрим три основных типа рисков по управлению:

1. **Ожидание ветвления (Branch Delay):**
   - Этот вид риска возникает из-за задержек, связанных с выполнением условных переходов (ветвлений). Перед тем как известно, куда выполнение должно перейти, необходимо дождаться результата условия. Это создает задержку, поскольку следующие инструкции в конвейере уже могли начать выполнение.

2. **Ожидание прыжка (Jump Delay):**
   - Аналогично ожиданию ветвления, ожидание прыжка возникает при выполнении инструкций, связанных с безусловными переходами, такими как инструкции перехода или вызова подпрограммы.

3. **Неопределенность ветвления (Branch Misprediction):**
   - Этот вид риска возникает, когда конвейер делает неверное предположение о том, куда следует перейти после условного перехода. Если предсказание оказывается неверным, требуется сброс конвейера и повторное выполнение инструкций с правильным адресом перехода.

Как управлять рисками по управлению в конвейерной обработке:

- **Использование предсказателей ветвления (Branch Predictors):** Эти механизмы предсказывают направление условного перехода на основе истории выполнения программы.

- **Использование техник предсказания прыжков (Jump Prediction):** Подобные механизмы предсказывают возможные адреса прыжка, что может сократить задержку при выполнении безусловных переходов.

- **Использование техник предсказания прыжков (Jump Prediction):** Техники предсказания прыжков аналогичны предсказателям ветвления, но ориентированы на безусловные переходы и вызовы подпрограмм.

- **Оптимизация конвейерной архитектуры:** Модернизация конвейеров, в том числе использование предсказателей ветвления, предсказания прыжков и других техник, может помочь снизить влияние рисков по управлению.

Управление рисками по управлению в конвейерной обработке важно для обеспечения эффективного выполнения программ и минимизации затрат времени на ожидание решений о переходах.
<div style="page-break-after: always;"></div>

# 45. Структурные конфликты в конвейере команд

> [!tldr] TL:DR
> - Структурные конфликты в конвейерной обработке команд возникают, когда двум инструкциям требуется одновременный доступ к аппаратному ресурсу, чаще всего при обращении к памяти.
> - Решение проблемы структурных конфликтов включает в себя обеспечение достаточного количества аппаратных ресурсов, таких как раздельные кэши команд и данных.
> - В конвейерной обработке скорость выполнения каждой команды остается прежней, но увеличивается количество команд, выполняемых за единицу времени.
> - Структурные конфликты могут привести к приостановке работы всего конвейера, если возникают заторы на какой-либо из его ступеней.
> - Управление структурными конфликтами включает в себя использование предсказателей структурных конфликтов, увеличение ресурсов, переупорядочение инструкций и применение многозадачности.

Причина – двум командам требуется одновременный доступ к аппаратному ресурсу. 

Структурные конфликты наиболее вероятны при обращении к памяти.

Решение – использование в процессоре достаточного количества аппаратных ресурсов, в частности, раздельных кэшей команд и данных.


![[Pasted image 20231220223256.png]]


Конвейерная обработка команд не приводит к ускорению выполнения каждой отдельной команды. 

Скорость команд остается прежней, но на единицу времени приходится большее их количество. 

При этом, как только на одной из ступеней конвейера возникает затор и работа не завершается за один такт, весь конвейер останавливается в ожидании завершения процесса. Если описанные ситуации возникают достаточно часто, производительность компьютера снижается. 

Важнейшей задачей разработчиков процессоров является выявление конфликтов, которые могут привести к приостановке процессора, и поиск путей их устранения.

В конвейерной обработке команд структурные конфликты (Structural Hazards) возникают из-за конфликтов в использовании ресурсов между различными ступенями конвейера. Эти конфликты могут привести к необходимости ожидания доступа к общим ресурсам и увеличению задержек в выполнении инструкций. Рассмотрим несколько видов структурных конфликтов:

1. **Конфликт по использованию функциональных блоков:**
   - Если несколько инструкций одновременно требуют использование одного и того же функционального блока (например, умножение), возникает конфликт.

2. **Конфликт по использованию портов памяти:**
   - Если несколько инструкций требуют доступ к одному и тому же порту памяти (чтение или запись), это может привести к конфликту.

3. **Конфликт по использованию регистров:**
   - Если несколько инструкций пытаются записать результат в один и тот же регистр или считать данные из одного и того же регистра, возникает конфликт.

4. **Конфликт по использованию арифметических блоков:**
   - Например, если несколько инструкций требуют выполнение арифметических операций (сложение, вычитание) в одном и том же арифметическом блоке.

5. **Конфликт по использованию устройств ввода-вывода (I/O):**
   - Если инструкции требуют доступа к устройствам ввода-вывода, например, при обращении к файлам, и эти устройства доступны только для одной инструкции в определенный момент времени.

Как управлять структурными конфликтами:

- **Структурное предсказание (Structural Prediction):** Некоторые архитектуры могут внедрять механизмы предсказания структурных конфликтов, чтобы оптимизировать доступ к ресурсам.

- **Увеличение ресурсов:** Расширение аппаратных ресурсов (например, добавление дополнительных функциональных блоков или портов памяти) может уменьшить вероятность структурных конфликтов.

- **Переупорядочение инструкций (Instruction Reordering):** Перестановка порядка выполнения инструкций может помочь избежать структурных конфликтов.

- **Многозадачность (Multithreading):** Реализация многозадачности может позволить процессору выполнять другие инструкции в ожидании разрешения структурных конфликтов.

Управление структурными конфликтами важно для поддержания высокой производительности конвейерной обработки команд и минимизации затрат времени на ожидание ресурсов.